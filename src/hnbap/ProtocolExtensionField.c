/*
 * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
 * From ASN.1 module "HNBAP-Containers"
 * 	found in "../../asn1/hnbap/hnbap-14.0.0.asn1"
 * 	`asn1c -fcompound-names -fno-include-deps -gen-PER -no-gen-example`
 */

#include <osmocom/hnbap/ProtocolExtensionField.h>

static const long asn_VAL_1_id_Service_Area_For_Broadcast = 20;
static const long asn_VAL_1_ignore = 1;
static const long asn_VAL_1_optional = 0;
static const long asn_VAL_2_id_HNB_Cell_Access_Mode = 18;
static const long asn_VAL_2_reject = 0;
static const long asn_VAL_2_optional = 0;
static const long asn_VAL_3_id_PSC = 30;
static const long asn_VAL_3_ignore = 1;
static const long asn_VAL_3_optional = 0;
static const long asn_VAL_4_id_Iurh_Signalling_TNL_Address = 29;
static const long asn_VAL_4_ignore = 1;
static const long asn_VAL_4_optional = 0;
static const long asn_VAL_5_id_Tunnel_Information = 41;
static const long asn_VAL_5_ignore = 1;
static const long asn_VAL_5_optional = 0;
static const long asn_VAL_6_id_CELL_FACHMobilitySupport = 42;
static const long asn_VAL_6_ignore = 1;
static const long asn_VAL_6_optional = 0;
static const long asn_VAL_7_id_NeighbourCellIdentityList = 47;
static const long asn_VAL_7_ignore = 1;
static const long asn_VAL_7_optional = 0;
static const long asn_VAL_8_id_URAIdentityList = 52;
static const long asn_VAL_8_ignore = 1;
static const long asn_VAL_8_optional = 0;
static const long asn_VAL_9_id_HNBCapacity = 46;
static const long asn_VAL_9_ignore = 1;
static const long asn_VAL_9_optional = 0;
static const asn_ioc_cell_t asn_IOS_HNBRegisterRequestExtensions_1_rows[] = {
	{ "&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_1_id_Service_Area_For_Broadcast },
	{ "&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_1_ignore },
	{ "&Extension", aioc__type, &asn_DEF_SAC },
	{ "&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_1_optional },
	{ "&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_2_id_HNB_Cell_Access_Mode },
	{ "&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_2_reject },
	{ "&Extension", aioc__type, &asn_DEF_HNB_Cell_Access_Mode },
	{ "&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_2_optional },
	{ "&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_3_id_PSC },
	{ "&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_3_ignore },
	{ "&Extension", aioc__type, &asn_DEF_PSC },
	{ "&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_3_optional },
	{ "&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_4_id_Iurh_Signalling_TNL_Address },
	{ "&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_4_ignore },
	{ "&Extension", aioc__type, &asn_DEF_IP_Address },
	{ "&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_4_optional },
	{ "&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_5_id_Tunnel_Information },
	{ "&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_5_ignore },
	{ "&Extension", aioc__type, &asn_DEF_Tunnel_Information },
	{ "&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_5_optional },
	{ "&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_6_id_CELL_FACHMobilitySupport },
	{ "&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_6_ignore },
	{ "&Extension", aioc__type, &asn_DEF_CELL_FACHMobilitySupport },
	{ "&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_6_optional },
	{ "&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_7_id_NeighbourCellIdentityList },
	{ "&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_7_ignore },
	{ "&Extension", aioc__type, &asn_DEF_NeighbourCellIdentityList },
	{ "&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_7_optional },
	{ "&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_8_id_URAIdentityList },
	{ "&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_8_ignore },
	{ "&Extension", aioc__type, &asn_DEF_URAIdentityList },
	{ "&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_8_optional },
	{ "&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_9_id_HNBCapacity },
	{ "&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_9_ignore },
	{ "&Extension", aioc__type, &asn_DEF_HNBCapacity },
	{ "&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_9_optional }
};
static const asn_ioc_set_t asn_IOS_HNBRegisterRequestExtensions_1[] = {
	{ 9, 4, asn_IOS_HNBRegisterRequestExtensions_1_rows }
};
static const long asn_VAL_10_id_MuxPortNumber = 19;
static const long asn_VAL_10_ignore = 1;
static const long asn_VAL_10_optional = 0;
static const long asn_VAL_11_id_Iurh_Signalling_TNL_Address = 29;
static const long asn_VAL_11_ignore = 1;
static const long asn_VAL_11_optional = 0;
static const long asn_VAL_12_id_S_RNTIPrefix = 43;
static const long asn_VAL_12_ignore = 1;
static const long asn_VAL_12_optional = 0;
static const asn_ioc_cell_t asn_IOS_HNBRegisterResponseExtensions_1_rows[] = {
	{ "&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_10_id_MuxPortNumber },
	{ "&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_10_ignore },
	{ "&Extension", aioc__type, &asn_DEF_MuxPortNumber },
	{ "&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_10_optional },
	{ "&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_11_id_Iurh_Signalling_TNL_Address },
	{ "&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_11_ignore },
	{ "&Extension", aioc__type, &asn_DEF_IP_Address },
	{ "&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_11_optional },
	{ "&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_12_id_S_RNTIPrefix },
	{ "&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_12_ignore },
	{ "&Extension", aioc__type, &asn_DEF_S_RNTIPrefix },
	{ "&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_12_optional }
};
static const asn_ioc_set_t asn_IOS_HNBRegisterResponseExtensions_1[] = {
	{ 3, 4, asn_IOS_HNBRegisterResponseExtensions_1_rows }
};
static const long asn_VAL_13_id_CSGMembershipStatus = 21;
static const long asn_VAL_13_reject = 0;
static const long asn_VAL_13_optional = 0;
static const asn_ioc_cell_t asn_IOS_UERegisterAcceptExtensions_1_rows[] = {
	{ "&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_13_id_CSGMembershipStatus },
	{ "&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_13_reject },
	{ "&Extension", aioc__type, &asn_DEF_CSGMembershipStatus },
	{ "&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_13_optional }
};
static const asn_ioc_set_t asn_IOS_UERegisterAcceptExtensions_1[] = {
	{ 1, 4, asn_IOS_UERegisterAcceptExtensions_1_rows }
};
static const long asn_VAL_14_id_AdditionalNeighbourInfoList = 48;
static const long asn_VAL_14_ignore = 1;
static const long asn_VAL_14_optional = 0;
static const asn_ioc_cell_t asn_IOS_HNBConfigTransferResponseExtensions_1_rows[] = {
	{ "&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_14_id_AdditionalNeighbourInfoList },
	{ "&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_14_ignore },
	{ "&Extension", aioc__type, &asn_DEF_AdditionalNeighbourInfoList },
	{ "&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_14_optional }
};
static const asn_ioc_set_t asn_IOS_HNBConfigTransferResponseExtensions_1[] = {
	{ 1, 4, asn_IOS_HNBConfigTransferResponseExtensions_1_rows }
};
static const long asn_VAL_15_id_S_RNTIPrefix = 43;
static const long asn_VAL_15_ignore = 1;
static const long asn_VAL_15_optional = 0;
static const long asn_VAL_16_id_URAIdentityList = 52;
static const long asn_VAL_16_ignore = 1;
static const long asn_VAL_16_optional = 0;
static const asn_ioc_cell_t asn_IOS_HNBConfigurationInformationProvided_ExtIEs_1_rows[] = {
	{ "&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_15_id_S_RNTIPrefix },
	{ "&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_15_ignore },
	{ "&Extension", aioc__type, &asn_DEF_S_RNTIPrefix },
	{ "&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_15_optional },
	{ "&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_16_id_URAIdentityList },
	{ "&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_16_ignore },
	{ "&Extension", aioc__type, &asn_DEF_URAIdentityList },
	{ "&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_16_optional }
};
static const asn_ioc_set_t asn_IOS_HNBConfigurationInformationProvided_ExtIEs_1[] = {
	{ 2, 4, asn_IOS_HNBConfigurationInformationProvided_ExtIEs_1_rows }
};
static const long asn_VAL_17_id_HNB_Internet_Information = 17;
static const long asn_VAL_17_reject = 0;
static const long asn_VAL_17_optional = 0;
static const asn_ioc_cell_t asn_IOS_HNB_Location_Information_ExtIEs_1_rows[] = {
	{ "&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_17_id_HNB_Internet_Information },
	{ "&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_17_reject },
	{ "&Extension", aioc__type, &asn_DEF_IP_Address },
	{ "&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_17_optional }
};
static const asn_ioc_set_t asn_IOS_HNB_Location_Information_ExtIEs_1[] = {
	{ 1, 4, asn_IOS_HNB_Location_Information_ExtIEs_1_rows }
};
static int
memb_id_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static asn_type_selector_result_t
select_HNBRegisterRequestExtensions_criticality_type(const asn_TYPE_descriptor_t *parent_type, const void *parent_sptr) {
	asn_type_selector_result_t result = {0, 0};
	const asn_ioc_set_t *itable = asn_IOS_HNBRegisterRequestExtensions_1;
	size_t constraining_column = 0; /* &id */
	size_t for_column = 1; /* &criticality */
	size_t row, presence_index = 0;
	const long *constraining_value = (const long *)((const char *)parent_sptr + offsetof(struct HNBRegisterRequestExtensions, id));
	
	for(row=0; row < itable->rows_count; row++) {
	    const asn_ioc_cell_t *constraining_cell = &itable->rows[row * itable->columns_count + constraining_column];
	    const asn_ioc_cell_t *type_cell = &itable->rows[row * itable->columns_count + for_column];
	
	    if(type_cell->cell_kind == aioc__undefined)
	        continue;
	
	    presence_index++;
	    if(constraining_cell->type_descriptor->op->compare_struct(constraining_cell->type_descriptor, constraining_value, constraining_cell->value_sptr) == 0) {
	        result.type_descriptor = type_cell->type_descriptor;
	        result.presence_index = presence_index;
	        break;
	    }
	}
	
	return result;
}

static int
memb_criticality_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_HNBRegisterRequestExtensions_extensionValue_type(const asn_TYPE_descriptor_t *parent_type, const void *parent_sptr) {
	asn_type_selector_result_t result = {0, 0};
	const asn_ioc_set_t *itable = asn_IOS_HNBRegisterRequestExtensions_1;
	size_t constraining_column = 0; /* &id */
	size_t for_column = 2; /* &Extension */
	size_t row, presence_index = 0;
	const long *constraining_value = (const long *)((const char *)parent_sptr + offsetof(struct HNBRegisterRequestExtensions, id));
	
	for(row=0; row < itable->rows_count; row++) {
	    const asn_ioc_cell_t *constraining_cell = &itable->rows[row * itable->columns_count + constraining_column];
	    const asn_ioc_cell_t *type_cell = &itable->rows[row * itable->columns_count + for_column];
	
	    if(type_cell->cell_kind == aioc__undefined)
	        continue;
	
	    presence_index++;
	    if(constraining_cell->type_descriptor->op->compare_struct(constraining_cell->type_descriptor, constraining_value, constraining_cell->value_sptr) == 0) {
	        result.type_descriptor = type_cell->type_descriptor;
	        result.presence_index = presence_index;
	        break;
	    }
	}
	
	return result;
}

static int
memb_extensionValue_constraint_1(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_5(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static asn_type_selector_result_t
select_HNBRegisterResponseExtensions_criticality_type(const asn_TYPE_descriptor_t *parent_type, const void *parent_sptr) {
	asn_type_selector_result_t result = {0, 0};
	const asn_ioc_set_t *itable = asn_IOS_HNBRegisterResponseExtensions_1;
	size_t constraining_column = 0; /* &id */
	size_t for_column = 1; /* &criticality */
	size_t row, presence_index = 0;
	const long *constraining_value = (const long *)((const char *)parent_sptr + offsetof(struct HNBRegisterResponseExtensions, id));
	
	for(row=0; row < itable->rows_count; row++) {
	    const asn_ioc_cell_t *constraining_cell = &itable->rows[row * itable->columns_count + constraining_column];
	    const asn_ioc_cell_t *type_cell = &itable->rows[row * itable->columns_count + for_column];
	
	    if(type_cell->cell_kind == aioc__undefined)
	        continue;
	
	    presence_index++;
	    if(constraining_cell->type_descriptor->op->compare_struct(constraining_cell->type_descriptor, constraining_value, constraining_cell->value_sptr) == 0) {
	        result.type_descriptor = type_cell->type_descriptor;
	        result.presence_index = presence_index;
	        break;
	    }
	}
	
	return result;
}

static int
memb_criticality_constraint_5(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_HNBRegisterResponseExtensions_extensionValue_type(const asn_TYPE_descriptor_t *parent_type, const void *parent_sptr) {
	asn_type_selector_result_t result = {0, 0};
	const asn_ioc_set_t *itable = asn_IOS_HNBRegisterResponseExtensions_1;
	size_t constraining_column = 0; /* &id */
	size_t for_column = 2; /* &Extension */
	size_t row, presence_index = 0;
	const long *constraining_value = (const long *)((const char *)parent_sptr + offsetof(struct HNBRegisterResponseExtensions, id));
	
	for(row=0; row < itable->rows_count; row++) {
	    const asn_ioc_cell_t *constraining_cell = &itable->rows[row * itable->columns_count + constraining_column];
	    const asn_ioc_cell_t *type_cell = &itable->rows[row * itable->columns_count + for_column];
	
	    if(type_cell->cell_kind == aioc__undefined)
	        continue;
	
	    presence_index++;
	    if(constraining_cell->type_descriptor->op->compare_struct(constraining_cell->type_descriptor, constraining_value, constraining_cell->value_sptr) == 0) {
	        result.type_descriptor = type_cell->type_descriptor;
	        result.presence_index = presence_index;
	        break;
	    }
	}
	
	return result;
}

static int
memb_extensionValue_constraint_5(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_9(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_9(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_9(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_13(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_13(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_13(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_17(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_17(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_17(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_21(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static asn_type_selector_result_t
select_UERegisterAcceptExtensions_criticality_type(const asn_TYPE_descriptor_t *parent_type, const void *parent_sptr) {
	asn_type_selector_result_t result = {0, 0};
	const asn_ioc_set_t *itable = asn_IOS_UERegisterAcceptExtensions_1;
	size_t constraining_column = 0; /* &id */
	size_t for_column = 1; /* &criticality */
	size_t row, presence_index = 0;
	const long *constraining_value = (const long *)((const char *)parent_sptr + offsetof(struct UERegisterAcceptExtensions, id));
	
	for(row=0; row < itable->rows_count; row++) {
	    const asn_ioc_cell_t *constraining_cell = &itable->rows[row * itable->columns_count + constraining_column];
	    const asn_ioc_cell_t *type_cell = &itable->rows[row * itable->columns_count + for_column];
	
	    if(type_cell->cell_kind == aioc__undefined)
	        continue;
	
	    presence_index++;
	    if(constraining_cell->type_descriptor->op->compare_struct(constraining_cell->type_descriptor, constraining_value, constraining_cell->value_sptr) == 0) {
	        result.type_descriptor = type_cell->type_descriptor;
	        result.presence_index = presence_index;
	        break;
	    }
	}
	
	return result;
}

static int
memb_criticality_constraint_21(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_UERegisterAcceptExtensions_extensionValue_type(const asn_TYPE_descriptor_t *parent_type, const void *parent_sptr) {
	asn_type_selector_result_t result = {0, 0};
	const asn_ioc_set_t *itable = asn_IOS_UERegisterAcceptExtensions_1;
	size_t constraining_column = 0; /* &id */
	size_t for_column = 2; /* &Extension */
	size_t row, presence_index = 0;
	const long *constraining_value = (const long *)((const char *)parent_sptr + offsetof(struct UERegisterAcceptExtensions, id));
	
	for(row=0; row < itable->rows_count; row++) {
	    const asn_ioc_cell_t *constraining_cell = &itable->rows[row * itable->columns_count + constraining_column];
	    const asn_ioc_cell_t *type_cell = &itable->rows[row * itable->columns_count + for_column];
	
	    if(type_cell->cell_kind == aioc__undefined)
	        continue;
	
	    presence_index++;
	    if(constraining_cell->type_descriptor->op->compare_struct(constraining_cell->type_descriptor, constraining_value, constraining_cell->value_sptr) == 0) {
	        result.type_descriptor = type_cell->type_descriptor;
	        result.presence_index = presence_index;
	        break;
	    }
	}
	
	return result;
}

static int
memb_extensionValue_constraint_21(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_25(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_25(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_25(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_29(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_29(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_29(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_33(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_33(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_33(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_37(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_37(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_37(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_41(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_41(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_41(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_45(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_45(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_45(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_49(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_49(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_49(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_53(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static asn_type_selector_result_t
select_HNBConfigTransferResponseExtensions_criticality_type(const asn_TYPE_descriptor_t *parent_type, const void *parent_sptr) {
	asn_type_selector_result_t result = {0, 0};
	const asn_ioc_set_t *itable = asn_IOS_HNBConfigTransferResponseExtensions_1;
	size_t constraining_column = 0; /* &id */
	size_t for_column = 1; /* &criticality */
	size_t row, presence_index = 0;
	const long *constraining_value = (const long *)((const char *)parent_sptr + offsetof(struct HNBConfigTransferResponseExtensions, id));
	
	for(row=0; row < itable->rows_count; row++) {
	    const asn_ioc_cell_t *constraining_cell = &itable->rows[row * itable->columns_count + constraining_column];
	    const asn_ioc_cell_t *type_cell = &itable->rows[row * itable->columns_count + for_column];
	
	    if(type_cell->cell_kind == aioc__undefined)
	        continue;
	
	    presence_index++;
	    if(constraining_cell->type_descriptor->op->compare_struct(constraining_cell->type_descriptor, constraining_value, constraining_cell->value_sptr) == 0) {
	        result.type_descriptor = type_cell->type_descriptor;
	        result.presence_index = presence_index;
	        break;
	    }
	}
	
	return result;
}

static int
memb_criticality_constraint_53(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_HNBConfigTransferResponseExtensions_extensionValue_type(const asn_TYPE_descriptor_t *parent_type, const void *parent_sptr) {
	asn_type_selector_result_t result = {0, 0};
	const asn_ioc_set_t *itable = asn_IOS_HNBConfigTransferResponseExtensions_1;
	size_t constraining_column = 0; /* &id */
	size_t for_column = 2; /* &Extension */
	size_t row, presence_index = 0;
	const long *constraining_value = (const long *)((const char *)parent_sptr + offsetof(struct HNBConfigTransferResponseExtensions, id));
	
	for(row=0; row < itable->rows_count; row++) {
	    const asn_ioc_cell_t *constraining_cell = &itable->rows[row * itable->columns_count + constraining_column];
	    const asn_ioc_cell_t *type_cell = &itable->rows[row * itable->columns_count + for_column];
	
	    if(type_cell->cell_kind == aioc__undefined)
	        continue;
	
	    presence_index++;
	    if(constraining_cell->type_descriptor->op->compare_struct(constraining_cell->type_descriptor, constraining_value, constraining_cell->value_sptr) == 0) {
	        result.type_descriptor = type_cell->type_descriptor;
	        result.presence_index = presence_index;
	        break;
	    }
	}
	
	return result;
}

static int
memb_extensionValue_constraint_53(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_57(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_57(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_57(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_61(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_61(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_61(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_65(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_65(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_65(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_69(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_69(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_69(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_73(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_73(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_73(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_77(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_77(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_77(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_81(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_81(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_81(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_85(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_85(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_85(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_89(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_89(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_89(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_93(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_93(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_93(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_97(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_97(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_97(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_101(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static asn_type_selector_result_t
select_HNBConfigurationInformationProvided_ExtIEs_criticality_type(const asn_TYPE_descriptor_t *parent_type, const void *parent_sptr) {
	asn_type_selector_result_t result = {0, 0};
	const asn_ioc_set_t *itable = asn_IOS_HNBConfigurationInformationProvided_ExtIEs_1;
	size_t constraining_column = 0; /* &id */
	size_t for_column = 1; /* &criticality */
	size_t row, presence_index = 0;
	const long *constraining_value = (const long *)((const char *)parent_sptr + offsetof(struct HNBConfigurationInformationProvided_ExtIEs, id));
	
	for(row=0; row < itable->rows_count; row++) {
	    const asn_ioc_cell_t *constraining_cell = &itable->rows[row * itable->columns_count + constraining_column];
	    const asn_ioc_cell_t *type_cell = &itable->rows[row * itable->columns_count + for_column];
	
	    if(type_cell->cell_kind == aioc__undefined)
	        continue;
	
	    presence_index++;
	    if(constraining_cell->type_descriptor->op->compare_struct(constraining_cell->type_descriptor, constraining_value, constraining_cell->value_sptr) == 0) {
	        result.type_descriptor = type_cell->type_descriptor;
	        result.presence_index = presence_index;
	        break;
	    }
	}
	
	return result;
}

static int
memb_criticality_constraint_101(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_HNBConfigurationInformationProvided_ExtIEs_extensionValue_type(const asn_TYPE_descriptor_t *parent_type, const void *parent_sptr) {
	asn_type_selector_result_t result = {0, 0};
	const asn_ioc_set_t *itable = asn_IOS_HNBConfigurationInformationProvided_ExtIEs_1;
	size_t constraining_column = 0; /* &id */
	size_t for_column = 2; /* &Extension */
	size_t row, presence_index = 0;
	const long *constraining_value = (const long *)((const char *)parent_sptr + offsetof(struct HNBConfigurationInformationProvided_ExtIEs, id));
	
	for(row=0; row < itable->rows_count; row++) {
	    const asn_ioc_cell_t *constraining_cell = &itable->rows[row * itable->columns_count + constraining_column];
	    const asn_ioc_cell_t *type_cell = &itable->rows[row * itable->columns_count + for_column];
	
	    if(type_cell->cell_kind == aioc__undefined)
	        continue;
	
	    presence_index++;
	    if(constraining_cell->type_descriptor->op->compare_struct(constraining_cell->type_descriptor, constraining_value, constraining_cell->value_sptr) == 0) {
	        result.type_descriptor = type_cell->type_descriptor;
	        result.presence_index = presence_index;
	        break;
	    }
	}
	
	return result;
}

static int
memb_extensionValue_constraint_101(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_105(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_105(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_105(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_109(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static asn_type_selector_result_t
select_HNB_Location_Information_ExtIEs_criticality_type(const asn_TYPE_descriptor_t *parent_type, const void *parent_sptr) {
	asn_type_selector_result_t result = {0, 0};
	const asn_ioc_set_t *itable = asn_IOS_HNB_Location_Information_ExtIEs_1;
	size_t constraining_column = 0; /* &id */
	size_t for_column = 1; /* &criticality */
	size_t row, presence_index = 0;
	const long *constraining_value = (const long *)((const char *)parent_sptr + offsetof(struct HNB_Location_Information_ExtIEs, id));
	
	for(row=0; row < itable->rows_count; row++) {
	    const asn_ioc_cell_t *constraining_cell = &itable->rows[row * itable->columns_count + constraining_column];
	    const asn_ioc_cell_t *type_cell = &itable->rows[row * itable->columns_count + for_column];
	
	    if(type_cell->cell_kind == aioc__undefined)
	        continue;
	
	    presence_index++;
	    if(constraining_cell->type_descriptor->op->compare_struct(constraining_cell->type_descriptor, constraining_value, constraining_cell->value_sptr) == 0) {
	        result.type_descriptor = type_cell->type_descriptor;
	        result.presence_index = presence_index;
	        break;
	    }
	}
	
	return result;
}

static int
memb_criticality_constraint_109(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_HNB_Location_Information_ExtIEs_extensionValue_type(const asn_TYPE_descriptor_t *parent_type, const void *parent_sptr) {
	asn_type_selector_result_t result = {0, 0};
	const asn_ioc_set_t *itable = asn_IOS_HNB_Location_Information_ExtIEs_1;
	size_t constraining_column = 0; /* &id */
	size_t for_column = 2; /* &Extension */
	size_t row, presence_index = 0;
	const long *constraining_value = (const long *)((const char *)parent_sptr + offsetof(struct HNB_Location_Information_ExtIEs, id));
	
	for(row=0; row < itable->rows_count; row++) {
	    const asn_ioc_cell_t *constraining_cell = &itable->rows[row * itable->columns_count + constraining_column];
	    const asn_ioc_cell_t *type_cell = &itable->rows[row * itable->columns_count + for_column];
	
	    if(type_cell->cell_kind == aioc__undefined)
	        continue;
	
	    presence_index++;
	    if(constraining_cell->type_descriptor->op->compare_struct(constraining_cell->type_descriptor, constraining_value, constraining_cell->value_sptr) == 0) {
	        result.type_descriptor = type_cell->type_descriptor;
	        result.presence_index = presence_index;
	        break;
	    }
	}
	
	return result;
}

static int
memb_extensionValue_constraint_109(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_113(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_113(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_113(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_117(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_117(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_117(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_121(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_121(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_121(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_125(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_125(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_125(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_129(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_129(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_129(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_133(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_133(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_133(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_137(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_137(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_137(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_141(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_141(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_141(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_id_constraint_145(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	long value;
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	value = *(const long *)sptr;
	
	if((value >= 0 && value <= 65535)) {
		/* Constraint check succeeded */
		return 0;
	} else {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: constraint failed (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
}

static int
memb_criticality_constraint_145(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static int
memb_extensionValue_constraint_145(const asn_TYPE_descriptor_t *td, const void *sptr,
			asn_app_constraint_failed_f *ctfailcb, void *app_key) {
	
	if(!sptr) {
		ASN__CTFAIL(app_key, td, sptr,
			"%s: value not given (%s:%d)",
			td->name, __FILE__, __LINE__);
		return -1;
	}
	
	
	if(1 /* No applicable constraints whatsoever */) {
		/* Nothing is here. See below */
	}
	
	return td->encoding_constraints.general_constraints(td, sptr, ctfailcb, app_key);
}

static asn_oer_constraints_t asn_OER_memb_id_constr_2 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_2 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_3 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_3 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_4 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_4 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_6 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_6 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_7 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_7 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_8 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_8 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_10 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_10 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_11 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_11 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_12 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_12 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_14 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_14 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_15 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_15 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_16 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_16 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_18 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_18 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_19 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_19 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_20 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_20 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_22 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_22 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_23 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_23 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_24 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_24 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_26 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_26 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_27 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_27 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_28 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_28 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_30 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_30 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_31 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_31 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_32 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_32 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_34 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_34 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_35 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_35 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_36 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_36 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_38 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_38 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_39 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_39 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_40 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_40 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_42 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_42 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_43 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_43 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_44 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_44 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_46 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_46 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_47 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_47 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_48 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_48 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_50 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_50 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_51 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_51 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_52 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_52 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_54 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_54 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_55 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_55 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_56 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_56 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_58 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_58 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_59 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_59 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_60 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_60 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_62 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_62 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_63 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_63 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_64 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_64 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_66 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_66 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_67 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_67 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_68 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_68 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_70 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_70 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_71 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_71 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_72 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_72 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_74 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_74 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_75 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_75 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_76 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_76 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_78 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_78 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_79 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_79 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_80 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_80 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_82 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_82 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_83 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_83 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_84 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_84 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_86 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_86 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_87 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_87 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_88 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_88 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_90 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_90 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_91 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_91 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_92 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_92 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_94 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_94 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_95 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_95 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_96 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_96 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_98 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_98 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_99 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_99 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_100 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_100 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_102 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_102 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_103 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_103 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_104 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_104 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_106 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_106 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_107 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_107 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_108 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_108 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_110 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_110 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_111 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_111 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_112 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_112 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_114 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_114 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_115 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_115 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_116 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_116 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_118 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_118 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_119 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_119 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_120 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_120 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_122 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_122 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_123 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_123 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_124 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_124 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_126 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_126 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_127 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_127 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_128 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_128 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_130 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_130 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_131 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_131 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_132 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_132 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_134 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_134 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_135 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_135 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_136 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_136 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_138 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_138 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_139 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_139 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_140 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_140 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_142 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_142 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_143 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_143 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_144 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_144 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_id_constr_146 CC_NOTUSED = {
	{ 2, 1 }	/* (0..65535) */,
	-1};
static asn_per_constraints_t asn_PER_memb_id_constr_146 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 16,  16,  0,  65535 }	/* (0..65535) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_criticality_constr_147 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_criticality_constr_147 CC_NOTUSED = {
	{ APC_CONSTRAINED,	 2,  2,  0,  2 }	/* (0..2) */,
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_oer_constraints_t asn_OER_memb_extensionValue_constr_148 CC_NOTUSED = {
	{ 0, 0 },
	-1};
static asn_per_constraints_t asn_PER_memb_extensionValue_constr_148 CC_NOTUSED = {
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	{ APC_UNCONSTRAINED,	-1, -1,  0,  0 },
	0, 0	/* No PER value map */
};
static asn_TYPE_member_t asn_MBR_extensionValue_4[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct HNBRegisterRequestExtensions__extensionValue, choice.SAC),
		(ASN_TAG_CLASS_UNIVERSAL | (4 << 2)),
		0,
		&asn_DEF_SAC,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"SAC"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBRegisterRequestExtensions__extensionValue, choice.HNB_Cell_Access_Mode),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_HNB_Cell_Access_Mode,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"HNB-Cell-Access-Mode"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBRegisterRequestExtensions__extensionValue, choice.PSC),
		(ASN_TAG_CLASS_UNIVERSAL | (3 << 2)),
		0,
		&asn_DEF_PSC,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"PSC"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBRegisterRequestExtensions__extensionValue, choice.IP_Address),
		(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		0,
		&asn_DEF_IP_Address,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"IP-Address"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBRegisterRequestExtensions__extensionValue, choice.Tunnel_Information),
		(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		0,
		&asn_DEF_Tunnel_Information,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"Tunnel-Information"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBRegisterRequestExtensions__extensionValue, choice.CELL_FACHMobilitySupport),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_CELL_FACHMobilitySupport,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"CELL-FACHMobilitySupport"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBRegisterRequestExtensions__extensionValue, choice.NeighbourCellIdentityList),
		(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		0,
		&asn_DEF_NeighbourCellIdentityList,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"NeighbourCellIdentityList"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBRegisterRequestExtensions__extensionValue, choice.URAIdentityList),
		(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		0,
		&asn_DEF_URAIdentityList,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"URAIdentityList"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBRegisterRequestExtensions__extensionValue, choice.HNBCapacity),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_HNBCapacity,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"HNBCapacity"
		},
};
static const unsigned asn_MAP_extensionValue_to_canonical_4[] = { 8, 2, 0, 1, 5, 3, 4, 6, 7 };
static const unsigned asn_MAP_extensionValue_from_canonical_4[] = { 2, 3, 1, 5, 6, 4, 7, 8, 0 };
static const asn_TYPE_tag2member_t asn_MAP_extensionValue_tag2el_4[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 8, 0, 0 }, /* HNBCapacity */
    { (ASN_TAG_CLASS_UNIVERSAL | (3 << 2)), 2, 0, 0 }, /* PSC */
    { (ASN_TAG_CLASS_UNIVERSAL | (4 << 2)), 0, 0, 0 }, /* SAC */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 1 }, /* HNB-Cell-Access-Mode */
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 5, -1, 0 }, /* CELL-FACHMobilitySupport */
    { (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 3, 0, 3 }, /* IP-Address */
    { (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 4, -1, 2 }, /* Tunnel-Information */
    { (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 6, -2, 1 }, /* NeighbourCellIdentityList */
    { (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 7, -3, 0 } /* URAIdentityList */
};
static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_4 = {
	sizeof(struct HNBRegisterRequestExtensions__extensionValue),
	offsetof(struct HNBRegisterRequestExtensions__extensionValue, _asn_ctx),
	offsetof(struct HNBRegisterRequestExtensions__extensionValue, present),
	sizeof(((struct HNBRegisterRequestExtensions__extensionValue *)0)->present),
	asn_MAP_extensionValue_tag2el_4,
	9,	/* Count of tags in the map */
	asn_MAP_extensionValue_to_canonical_4,
	asn_MAP_extensionValue_from_canonical_4,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_4 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	asn_MBR_extensionValue_4,
	9,	/* Elements count */
	&asn_SPC_extensionValue_specs_4	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_HNBRegisterRequestExtensions_1[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct HNBRegisterRequestExtensions, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_2, &asn_PER_memb_id_constr_2,  memb_id_constraint_1 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBRegisterRequestExtensions, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		select_HNBRegisterRequestExtensions_criticality_type,
		{ &asn_OER_memb_criticality_constr_3, &asn_PER_memb_criticality_constr_3,  memb_criticality_constraint_1 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct HNBRegisterRequestExtensions, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_4,
		select_HNBRegisterRequestExtensions_extensionValue_type,
		{ &asn_OER_memb_extensionValue_constr_4, &asn_PER_memb_extensionValue_constr_4,  memb_extensionValue_constraint_1 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_HNBRegisterRequestExtensions_tags_1[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_HNBRegisterRequestExtensions_tag2el_1[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_HNBRegisterRequestExtensions_specs_1 = {
	sizeof(struct HNBRegisterRequestExtensions),
	offsetof(struct HNBRegisterRequestExtensions, _asn_ctx),
	asn_MAP_HNBRegisterRequestExtensions_tag2el_1,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_HNBRegisterRequestExtensions = {
	"HNBRegisterRequestExtensions",
	"HNBRegisterRequestExtensions",
	&asn_OP_SEQUENCE,
	asn_DEF_HNBRegisterRequestExtensions_tags_1,
	sizeof(asn_DEF_HNBRegisterRequestExtensions_tags_1)
		/sizeof(asn_DEF_HNBRegisterRequestExtensions_tags_1[0]), /* 1 */
	asn_DEF_HNBRegisterRequestExtensions_tags_1,	/* Same as above */
	sizeof(asn_DEF_HNBRegisterRequestExtensions_tags_1)
		/sizeof(asn_DEF_HNBRegisterRequestExtensions_tags_1[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_HNBRegisterRequestExtensions_1,
	3,	/* Elements count */
	&asn_SPC_HNBRegisterRequestExtensions_specs_1	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_extensionValue_8[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct HNBRegisterResponseExtensions__extensionValue, choice.MuxPortNumber),
		(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
		0,
		&asn_DEF_MuxPortNumber,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"MuxPortNumber"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBRegisterResponseExtensions__extensionValue, choice.IP_Address),
		(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		0,
		&asn_DEF_IP_Address,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"IP-Address"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBRegisterResponseExtensions__extensionValue, choice.S_RNTIPrefix),
		(ASN_TAG_CLASS_UNIVERSAL | (3 << 2)),
		0,
		&asn_DEF_S_RNTIPrefix,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"S-RNTIPrefix"
		},
};
static const unsigned asn_MAP_extensionValue_to_canonical_8[] = { 0, 2, 1 };
static const unsigned asn_MAP_extensionValue_from_canonical_8[] = { 0, 2, 1 };
static const asn_TYPE_tag2member_t asn_MAP_extensionValue_tag2el_8[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0 }, /* MuxPortNumber */
    { (ASN_TAG_CLASS_UNIVERSAL | (3 << 2)), 2, 0, 0 }, /* S-RNTIPrefix */
    { (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 1, 0, 0 } /* IP-Address */
};
static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_8 = {
	sizeof(struct HNBRegisterResponseExtensions__extensionValue),
	offsetof(struct HNBRegisterResponseExtensions__extensionValue, _asn_ctx),
	offsetof(struct HNBRegisterResponseExtensions__extensionValue, present),
	sizeof(((struct HNBRegisterResponseExtensions__extensionValue *)0)->present),
	asn_MAP_extensionValue_tag2el_8,
	3,	/* Count of tags in the map */
	asn_MAP_extensionValue_to_canonical_8,
	asn_MAP_extensionValue_from_canonical_8,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_8 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	asn_MBR_extensionValue_8,
	3,	/* Elements count */
	&asn_SPC_extensionValue_specs_8	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_HNBRegisterResponseExtensions_5[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct HNBRegisterResponseExtensions, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_6, &asn_PER_memb_id_constr_6,  memb_id_constraint_5 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBRegisterResponseExtensions, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		select_HNBRegisterResponseExtensions_criticality_type,
		{ &asn_OER_memb_criticality_constr_7, &asn_PER_memb_criticality_constr_7,  memb_criticality_constraint_5 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct HNBRegisterResponseExtensions, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_8,
		select_HNBRegisterResponseExtensions_extensionValue_type,
		{ &asn_OER_memb_extensionValue_constr_8, &asn_PER_memb_extensionValue_constr_8,  memb_extensionValue_constraint_5 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_HNBRegisterResponseExtensions_tags_5[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_HNBRegisterResponseExtensions_tag2el_5[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_HNBRegisterResponseExtensions_specs_5 = {
	sizeof(struct HNBRegisterResponseExtensions),
	offsetof(struct HNBRegisterResponseExtensions, _asn_ctx),
	asn_MAP_HNBRegisterResponseExtensions_tag2el_5,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_HNBRegisterResponseExtensions = {
	"HNBRegisterResponseExtensions",
	"HNBRegisterResponseExtensions",
	&asn_OP_SEQUENCE,
	asn_DEF_HNBRegisterResponseExtensions_tags_5,
	sizeof(asn_DEF_HNBRegisterResponseExtensions_tags_5)
		/sizeof(asn_DEF_HNBRegisterResponseExtensions_tags_5[0]), /* 1 */
	asn_DEF_HNBRegisterResponseExtensions_tags_5,	/* Same as above */
	sizeof(asn_DEF_HNBRegisterResponseExtensions_tags_5)
		/sizeof(asn_DEF_HNBRegisterResponseExtensions_tags_5[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_HNBRegisterResponseExtensions_5,
	3,	/* Elements count */
	&asn_SPC_HNBRegisterResponseExtensions_specs_5	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_12 = {
	sizeof(struct HNBRegisterRejectExtensions__extensionValue),
	offsetof(struct HNBRegisterRejectExtensions__extensionValue, _asn_ctx),
	offsetof(struct HNBRegisterRejectExtensions__extensionValue, present),
	sizeof(((struct HNBRegisterRejectExtensions__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_12 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_12	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_HNBRegisterRejectExtensions_9[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct HNBRegisterRejectExtensions, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_10, &asn_PER_memb_id_constr_10,  memb_id_constraint_9 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBRegisterRejectExtensions, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_11, &asn_PER_memb_criticality_constr_11,  memb_criticality_constraint_9 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct HNBRegisterRejectExtensions, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_12,
		0,
		{ &asn_OER_memb_extensionValue_constr_12, &asn_PER_memb_extensionValue_constr_12,  memb_extensionValue_constraint_9 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_HNBRegisterRejectExtensions_tags_9[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_HNBRegisterRejectExtensions_tag2el_9[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_HNBRegisterRejectExtensions_specs_9 = {
	sizeof(struct HNBRegisterRejectExtensions),
	offsetof(struct HNBRegisterRejectExtensions, _asn_ctx),
	asn_MAP_HNBRegisterRejectExtensions_tag2el_9,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_HNBRegisterRejectExtensions = {
	"HNBRegisterRejectExtensions",
	"HNBRegisterRejectExtensions",
	&asn_OP_SEQUENCE,
	asn_DEF_HNBRegisterRejectExtensions_tags_9,
	sizeof(asn_DEF_HNBRegisterRejectExtensions_tags_9)
		/sizeof(asn_DEF_HNBRegisterRejectExtensions_tags_9[0]), /* 1 */
	asn_DEF_HNBRegisterRejectExtensions_tags_9,	/* Same as above */
	sizeof(asn_DEF_HNBRegisterRejectExtensions_tags_9)
		/sizeof(asn_DEF_HNBRegisterRejectExtensions_tags_9[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_HNBRegisterRejectExtensions_9,
	3,	/* Elements count */
	&asn_SPC_HNBRegisterRejectExtensions_specs_9	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_16 = {
	sizeof(struct HNBDe_RegisterExtensions__extensionValue),
	offsetof(struct HNBDe_RegisterExtensions__extensionValue, _asn_ctx),
	offsetof(struct HNBDe_RegisterExtensions__extensionValue, present),
	sizeof(((struct HNBDe_RegisterExtensions__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_16 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_16	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_HNBDe_RegisterExtensions_13[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct HNBDe_RegisterExtensions, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_14, &asn_PER_memb_id_constr_14,  memb_id_constraint_13 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBDe_RegisterExtensions, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_15, &asn_PER_memb_criticality_constr_15,  memb_criticality_constraint_13 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct HNBDe_RegisterExtensions, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_16,
		0,
		{ &asn_OER_memb_extensionValue_constr_16, &asn_PER_memb_extensionValue_constr_16,  memb_extensionValue_constraint_13 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_HNBDe_RegisterExtensions_tags_13[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_HNBDe_RegisterExtensions_tag2el_13[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_HNBDe_RegisterExtensions_specs_13 = {
	sizeof(struct HNBDe_RegisterExtensions),
	offsetof(struct HNBDe_RegisterExtensions, _asn_ctx),
	asn_MAP_HNBDe_RegisterExtensions_tag2el_13,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_HNBDe_RegisterExtensions = {
	"HNBDe-RegisterExtensions",
	"HNBDe-RegisterExtensions",
	&asn_OP_SEQUENCE,
	asn_DEF_HNBDe_RegisterExtensions_tags_13,
	sizeof(asn_DEF_HNBDe_RegisterExtensions_tags_13)
		/sizeof(asn_DEF_HNBDe_RegisterExtensions_tags_13[0]), /* 1 */
	asn_DEF_HNBDe_RegisterExtensions_tags_13,	/* Same as above */
	sizeof(asn_DEF_HNBDe_RegisterExtensions_tags_13)
		/sizeof(asn_DEF_HNBDe_RegisterExtensions_tags_13[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_HNBDe_RegisterExtensions_13,
	3,	/* Elements count */
	&asn_SPC_HNBDe_RegisterExtensions_specs_13	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_20 = {
	sizeof(struct UERegisterRequestExtensions__extensionValue),
	offsetof(struct UERegisterRequestExtensions__extensionValue, _asn_ctx),
	offsetof(struct UERegisterRequestExtensions__extensionValue, present),
	sizeof(((struct UERegisterRequestExtensions__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_20 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_20	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_UERegisterRequestExtensions_17[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct UERegisterRequestExtensions, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_18, &asn_PER_memb_id_constr_18,  memb_id_constraint_17 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct UERegisterRequestExtensions, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_19, &asn_PER_memb_criticality_constr_19,  memb_criticality_constraint_17 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct UERegisterRequestExtensions, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_20,
		0,
		{ &asn_OER_memb_extensionValue_constr_20, &asn_PER_memb_extensionValue_constr_20,  memb_extensionValue_constraint_17 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_UERegisterRequestExtensions_tags_17[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_UERegisterRequestExtensions_tag2el_17[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_UERegisterRequestExtensions_specs_17 = {
	sizeof(struct UERegisterRequestExtensions),
	offsetof(struct UERegisterRequestExtensions, _asn_ctx),
	asn_MAP_UERegisterRequestExtensions_tag2el_17,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_UERegisterRequestExtensions = {
	"UERegisterRequestExtensions",
	"UERegisterRequestExtensions",
	&asn_OP_SEQUENCE,
	asn_DEF_UERegisterRequestExtensions_tags_17,
	sizeof(asn_DEF_UERegisterRequestExtensions_tags_17)
		/sizeof(asn_DEF_UERegisterRequestExtensions_tags_17[0]), /* 1 */
	asn_DEF_UERegisterRequestExtensions_tags_17,	/* Same as above */
	sizeof(asn_DEF_UERegisterRequestExtensions_tags_17)
		/sizeof(asn_DEF_UERegisterRequestExtensions_tags_17[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_UERegisterRequestExtensions_17,
	3,	/* Elements count */
	&asn_SPC_UERegisterRequestExtensions_specs_17	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_extensionValue_24[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct UERegisterAcceptExtensions__extensionValue, choice.CSGMembershipStatus),
		(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
		0,
		&asn_DEF_CSGMembershipStatus,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"CSGMembershipStatus"
		},
};
static const asn_TYPE_tag2member_t asn_MAP_extensionValue_tag2el_24[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 0, 0, 0 } /* CSGMembershipStatus */
};
static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_24 = {
	sizeof(struct UERegisterAcceptExtensions__extensionValue),
	offsetof(struct UERegisterAcceptExtensions__extensionValue, _asn_ctx),
	offsetof(struct UERegisterAcceptExtensions__extensionValue, present),
	sizeof(((struct UERegisterAcceptExtensions__extensionValue *)0)->present),
	asn_MAP_extensionValue_tag2el_24,
	1,	/* Count of tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_24 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	asn_MBR_extensionValue_24,
	1,	/* Elements count */
	&asn_SPC_extensionValue_specs_24	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_UERegisterAcceptExtensions_21[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct UERegisterAcceptExtensions, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_22, &asn_PER_memb_id_constr_22,  memb_id_constraint_21 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct UERegisterAcceptExtensions, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		select_UERegisterAcceptExtensions_criticality_type,
		{ &asn_OER_memb_criticality_constr_23, &asn_PER_memb_criticality_constr_23,  memb_criticality_constraint_21 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct UERegisterAcceptExtensions, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_24,
		select_UERegisterAcceptExtensions_extensionValue_type,
		{ &asn_OER_memb_extensionValue_constr_24, &asn_PER_memb_extensionValue_constr_24,  memb_extensionValue_constraint_21 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_UERegisterAcceptExtensions_tags_21[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_UERegisterAcceptExtensions_tag2el_21[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_UERegisterAcceptExtensions_specs_21 = {
	sizeof(struct UERegisterAcceptExtensions),
	offsetof(struct UERegisterAcceptExtensions, _asn_ctx),
	asn_MAP_UERegisterAcceptExtensions_tag2el_21,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_UERegisterAcceptExtensions = {
	"UERegisterAcceptExtensions",
	"UERegisterAcceptExtensions",
	&asn_OP_SEQUENCE,
	asn_DEF_UERegisterAcceptExtensions_tags_21,
	sizeof(asn_DEF_UERegisterAcceptExtensions_tags_21)
		/sizeof(asn_DEF_UERegisterAcceptExtensions_tags_21[0]), /* 1 */
	asn_DEF_UERegisterAcceptExtensions_tags_21,	/* Same as above */
	sizeof(asn_DEF_UERegisterAcceptExtensions_tags_21)
		/sizeof(asn_DEF_UERegisterAcceptExtensions_tags_21[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_UERegisterAcceptExtensions_21,
	3,	/* Elements count */
	&asn_SPC_UERegisterAcceptExtensions_specs_21	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_28 = {
	sizeof(struct UERegisterRejectExtensions__extensionValue),
	offsetof(struct UERegisterRejectExtensions__extensionValue, _asn_ctx),
	offsetof(struct UERegisterRejectExtensions__extensionValue, present),
	sizeof(((struct UERegisterRejectExtensions__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_28 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_28	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_UERegisterRejectExtensions_25[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct UERegisterRejectExtensions, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_26, &asn_PER_memb_id_constr_26,  memb_id_constraint_25 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct UERegisterRejectExtensions, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_27, &asn_PER_memb_criticality_constr_27,  memb_criticality_constraint_25 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct UERegisterRejectExtensions, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_28,
		0,
		{ &asn_OER_memb_extensionValue_constr_28, &asn_PER_memb_extensionValue_constr_28,  memb_extensionValue_constraint_25 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_UERegisterRejectExtensions_tags_25[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_UERegisterRejectExtensions_tag2el_25[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_UERegisterRejectExtensions_specs_25 = {
	sizeof(struct UERegisterRejectExtensions),
	offsetof(struct UERegisterRejectExtensions, _asn_ctx),
	asn_MAP_UERegisterRejectExtensions_tag2el_25,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_UERegisterRejectExtensions = {
	"UERegisterRejectExtensions",
	"UERegisterRejectExtensions",
	&asn_OP_SEQUENCE,
	asn_DEF_UERegisterRejectExtensions_tags_25,
	sizeof(asn_DEF_UERegisterRejectExtensions_tags_25)
		/sizeof(asn_DEF_UERegisterRejectExtensions_tags_25[0]), /* 1 */
	asn_DEF_UERegisterRejectExtensions_tags_25,	/* Same as above */
	sizeof(asn_DEF_UERegisterRejectExtensions_tags_25)
		/sizeof(asn_DEF_UERegisterRejectExtensions_tags_25[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_UERegisterRejectExtensions_25,
	3,	/* Elements count */
	&asn_SPC_UERegisterRejectExtensions_specs_25	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_32 = {
	sizeof(struct UEDe_RegisterExtensions__extensionValue),
	offsetof(struct UEDe_RegisterExtensions__extensionValue, _asn_ctx),
	offsetof(struct UEDe_RegisterExtensions__extensionValue, present),
	sizeof(((struct UEDe_RegisterExtensions__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_32 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_32	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_UEDe_RegisterExtensions_29[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct UEDe_RegisterExtensions, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_30, &asn_PER_memb_id_constr_30,  memb_id_constraint_29 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct UEDe_RegisterExtensions, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_31, &asn_PER_memb_criticality_constr_31,  memb_criticality_constraint_29 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct UEDe_RegisterExtensions, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_32,
		0,
		{ &asn_OER_memb_extensionValue_constr_32, &asn_PER_memb_extensionValue_constr_32,  memb_extensionValue_constraint_29 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_UEDe_RegisterExtensions_tags_29[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_UEDe_RegisterExtensions_tag2el_29[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_UEDe_RegisterExtensions_specs_29 = {
	sizeof(struct UEDe_RegisterExtensions),
	offsetof(struct UEDe_RegisterExtensions, _asn_ctx),
	asn_MAP_UEDe_RegisterExtensions_tag2el_29,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_UEDe_RegisterExtensions = {
	"UEDe-RegisterExtensions",
	"UEDe-RegisterExtensions",
	&asn_OP_SEQUENCE,
	asn_DEF_UEDe_RegisterExtensions_tags_29,
	sizeof(asn_DEF_UEDe_RegisterExtensions_tags_29)
		/sizeof(asn_DEF_UEDe_RegisterExtensions_tags_29[0]), /* 1 */
	asn_DEF_UEDe_RegisterExtensions_tags_29,	/* Same as above */
	sizeof(asn_DEF_UEDe_RegisterExtensions_tags_29)
		/sizeof(asn_DEF_UEDe_RegisterExtensions_tags_29[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_UEDe_RegisterExtensions_29,
	3,	/* Elements count */
	&asn_SPC_UEDe_RegisterExtensions_specs_29	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_36 = {
	sizeof(struct CSGMembershipUpdateExtensions__extensionValue),
	offsetof(struct CSGMembershipUpdateExtensions__extensionValue, _asn_ctx),
	offsetof(struct CSGMembershipUpdateExtensions__extensionValue, present),
	sizeof(((struct CSGMembershipUpdateExtensions__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_36 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_36	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_CSGMembershipUpdateExtensions_33[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct CSGMembershipUpdateExtensions, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_34, &asn_PER_memb_id_constr_34,  memb_id_constraint_33 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct CSGMembershipUpdateExtensions, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_35, &asn_PER_memb_criticality_constr_35,  memb_criticality_constraint_33 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct CSGMembershipUpdateExtensions, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_36,
		0,
		{ &asn_OER_memb_extensionValue_constr_36, &asn_PER_memb_extensionValue_constr_36,  memb_extensionValue_constraint_33 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_CSGMembershipUpdateExtensions_tags_33[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_CSGMembershipUpdateExtensions_tag2el_33[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_CSGMembershipUpdateExtensions_specs_33 = {
	sizeof(struct CSGMembershipUpdateExtensions),
	offsetof(struct CSGMembershipUpdateExtensions, _asn_ctx),
	asn_MAP_CSGMembershipUpdateExtensions_tag2el_33,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_CSGMembershipUpdateExtensions = {
	"CSGMembershipUpdateExtensions",
	"CSGMembershipUpdateExtensions",
	&asn_OP_SEQUENCE,
	asn_DEF_CSGMembershipUpdateExtensions_tags_33,
	sizeof(asn_DEF_CSGMembershipUpdateExtensions_tags_33)
		/sizeof(asn_DEF_CSGMembershipUpdateExtensions_tags_33[0]), /* 1 */
	asn_DEF_CSGMembershipUpdateExtensions_tags_33,	/* Same as above */
	sizeof(asn_DEF_CSGMembershipUpdateExtensions_tags_33)
		/sizeof(asn_DEF_CSGMembershipUpdateExtensions_tags_33[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_CSGMembershipUpdateExtensions_33,
	3,	/* Elements count */
	&asn_SPC_CSGMembershipUpdateExtensions_specs_33	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_40 = {
	sizeof(struct TNLUpdateExtensions__extensionValue),
	offsetof(struct TNLUpdateExtensions__extensionValue, _asn_ctx),
	offsetof(struct TNLUpdateExtensions__extensionValue, present),
	sizeof(((struct TNLUpdateExtensions__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_40 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_40	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_TNLUpdateExtensions_37[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct TNLUpdateExtensions, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_38, &asn_PER_memb_id_constr_38,  memb_id_constraint_37 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct TNLUpdateExtensions, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_39, &asn_PER_memb_criticality_constr_39,  memb_criticality_constraint_37 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct TNLUpdateExtensions, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_40,
		0,
		{ &asn_OER_memb_extensionValue_constr_40, &asn_PER_memb_extensionValue_constr_40,  memb_extensionValue_constraint_37 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_TNLUpdateExtensions_tags_37[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_TNLUpdateExtensions_tag2el_37[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_TNLUpdateExtensions_specs_37 = {
	sizeof(struct TNLUpdateExtensions),
	offsetof(struct TNLUpdateExtensions, _asn_ctx),
	asn_MAP_TNLUpdateExtensions_tag2el_37,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_TNLUpdateExtensions = {
	"TNLUpdateExtensions",
	"TNLUpdateExtensions",
	&asn_OP_SEQUENCE,
	asn_DEF_TNLUpdateExtensions_tags_37,
	sizeof(asn_DEF_TNLUpdateExtensions_tags_37)
		/sizeof(asn_DEF_TNLUpdateExtensions_tags_37[0]), /* 1 */
	asn_DEF_TNLUpdateExtensions_tags_37,	/* Same as above */
	sizeof(asn_DEF_TNLUpdateExtensions_tags_37)
		/sizeof(asn_DEF_TNLUpdateExtensions_tags_37[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_TNLUpdateExtensions_37,
	3,	/* Elements count */
	&asn_SPC_TNLUpdateExtensions_specs_37	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_44 = {
	sizeof(struct TNLUpdateResponseExtensions__extensionValue),
	offsetof(struct TNLUpdateResponseExtensions__extensionValue, _asn_ctx),
	offsetof(struct TNLUpdateResponseExtensions__extensionValue, present),
	sizeof(((struct TNLUpdateResponseExtensions__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_44 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_44	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_TNLUpdateResponseExtensions_41[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct TNLUpdateResponseExtensions, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_42, &asn_PER_memb_id_constr_42,  memb_id_constraint_41 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct TNLUpdateResponseExtensions, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_43, &asn_PER_memb_criticality_constr_43,  memb_criticality_constraint_41 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct TNLUpdateResponseExtensions, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_44,
		0,
		{ &asn_OER_memb_extensionValue_constr_44, &asn_PER_memb_extensionValue_constr_44,  memb_extensionValue_constraint_41 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_TNLUpdateResponseExtensions_tags_41[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_TNLUpdateResponseExtensions_tag2el_41[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_TNLUpdateResponseExtensions_specs_41 = {
	sizeof(struct TNLUpdateResponseExtensions),
	offsetof(struct TNLUpdateResponseExtensions, _asn_ctx),
	asn_MAP_TNLUpdateResponseExtensions_tag2el_41,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_TNLUpdateResponseExtensions = {
	"TNLUpdateResponseExtensions",
	"TNLUpdateResponseExtensions",
	&asn_OP_SEQUENCE,
	asn_DEF_TNLUpdateResponseExtensions_tags_41,
	sizeof(asn_DEF_TNLUpdateResponseExtensions_tags_41)
		/sizeof(asn_DEF_TNLUpdateResponseExtensions_tags_41[0]), /* 1 */
	asn_DEF_TNLUpdateResponseExtensions_tags_41,	/* Same as above */
	sizeof(asn_DEF_TNLUpdateResponseExtensions_tags_41)
		/sizeof(asn_DEF_TNLUpdateResponseExtensions_tags_41[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_TNLUpdateResponseExtensions_41,
	3,	/* Elements count */
	&asn_SPC_TNLUpdateResponseExtensions_specs_41	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_48 = {
	sizeof(struct TNLUpdateFailureExtensions__extensionValue),
	offsetof(struct TNLUpdateFailureExtensions__extensionValue, _asn_ctx),
	offsetof(struct TNLUpdateFailureExtensions__extensionValue, present),
	sizeof(((struct TNLUpdateFailureExtensions__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_48 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_48	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_TNLUpdateFailureExtensions_45[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct TNLUpdateFailureExtensions, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_46, &asn_PER_memb_id_constr_46,  memb_id_constraint_45 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct TNLUpdateFailureExtensions, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_47, &asn_PER_memb_criticality_constr_47,  memb_criticality_constraint_45 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct TNLUpdateFailureExtensions, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_48,
		0,
		{ &asn_OER_memb_extensionValue_constr_48, &asn_PER_memb_extensionValue_constr_48,  memb_extensionValue_constraint_45 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_TNLUpdateFailureExtensions_tags_45[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_TNLUpdateFailureExtensions_tag2el_45[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_TNLUpdateFailureExtensions_specs_45 = {
	sizeof(struct TNLUpdateFailureExtensions),
	offsetof(struct TNLUpdateFailureExtensions, _asn_ctx),
	asn_MAP_TNLUpdateFailureExtensions_tag2el_45,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_TNLUpdateFailureExtensions = {
	"TNLUpdateFailureExtensions",
	"TNLUpdateFailureExtensions",
	&asn_OP_SEQUENCE,
	asn_DEF_TNLUpdateFailureExtensions_tags_45,
	sizeof(asn_DEF_TNLUpdateFailureExtensions_tags_45)
		/sizeof(asn_DEF_TNLUpdateFailureExtensions_tags_45[0]), /* 1 */
	asn_DEF_TNLUpdateFailureExtensions_tags_45,	/* Same as above */
	sizeof(asn_DEF_TNLUpdateFailureExtensions_tags_45)
		/sizeof(asn_DEF_TNLUpdateFailureExtensions_tags_45[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_TNLUpdateFailureExtensions_45,
	3,	/* Elements count */
	&asn_SPC_TNLUpdateFailureExtensions_specs_45	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_52 = {
	sizeof(struct HNBConfigTransferRequestExtensions__extensionValue),
	offsetof(struct HNBConfigTransferRequestExtensions__extensionValue, _asn_ctx),
	offsetof(struct HNBConfigTransferRequestExtensions__extensionValue, present),
	sizeof(((struct HNBConfigTransferRequestExtensions__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_52 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_52	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_HNBConfigTransferRequestExtensions_49[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct HNBConfigTransferRequestExtensions, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_50, &asn_PER_memb_id_constr_50,  memb_id_constraint_49 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBConfigTransferRequestExtensions, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_51, &asn_PER_memb_criticality_constr_51,  memb_criticality_constraint_49 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct HNBConfigTransferRequestExtensions, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_52,
		0,
		{ &asn_OER_memb_extensionValue_constr_52, &asn_PER_memb_extensionValue_constr_52,  memb_extensionValue_constraint_49 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_HNBConfigTransferRequestExtensions_tags_49[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_HNBConfigTransferRequestExtensions_tag2el_49[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_HNBConfigTransferRequestExtensions_specs_49 = {
	sizeof(struct HNBConfigTransferRequestExtensions),
	offsetof(struct HNBConfigTransferRequestExtensions, _asn_ctx),
	asn_MAP_HNBConfigTransferRequestExtensions_tag2el_49,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_HNBConfigTransferRequestExtensions = {
	"HNBConfigTransferRequestExtensions",
	"HNBConfigTransferRequestExtensions",
	&asn_OP_SEQUENCE,
	asn_DEF_HNBConfigTransferRequestExtensions_tags_49,
	sizeof(asn_DEF_HNBConfigTransferRequestExtensions_tags_49)
		/sizeof(asn_DEF_HNBConfigTransferRequestExtensions_tags_49[0]), /* 1 */
	asn_DEF_HNBConfigTransferRequestExtensions_tags_49,	/* Same as above */
	sizeof(asn_DEF_HNBConfigTransferRequestExtensions_tags_49)
		/sizeof(asn_DEF_HNBConfigTransferRequestExtensions_tags_49[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_HNBConfigTransferRequestExtensions_49,
	3,	/* Elements count */
	&asn_SPC_HNBConfigTransferRequestExtensions_specs_49	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_extensionValue_56[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct HNBConfigTransferResponseExtensions__extensionValue, choice.AdditionalNeighbourInfoList),
		(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		0,
		&asn_DEF_AdditionalNeighbourInfoList,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"AdditionalNeighbourInfoList"
		},
};
static const asn_TYPE_tag2member_t asn_MAP_extensionValue_tag2el_56[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0, 0 } /* AdditionalNeighbourInfoList */
};
static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_56 = {
	sizeof(struct HNBConfigTransferResponseExtensions__extensionValue),
	offsetof(struct HNBConfigTransferResponseExtensions__extensionValue, _asn_ctx),
	offsetof(struct HNBConfigTransferResponseExtensions__extensionValue, present),
	sizeof(((struct HNBConfigTransferResponseExtensions__extensionValue *)0)->present),
	asn_MAP_extensionValue_tag2el_56,
	1,	/* Count of tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_56 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	asn_MBR_extensionValue_56,
	1,	/* Elements count */
	&asn_SPC_extensionValue_specs_56	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_HNBConfigTransferResponseExtensions_53[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct HNBConfigTransferResponseExtensions, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_54, &asn_PER_memb_id_constr_54,  memb_id_constraint_53 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBConfigTransferResponseExtensions, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		select_HNBConfigTransferResponseExtensions_criticality_type,
		{ &asn_OER_memb_criticality_constr_55, &asn_PER_memb_criticality_constr_55,  memb_criticality_constraint_53 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct HNBConfigTransferResponseExtensions, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_56,
		select_HNBConfigTransferResponseExtensions_extensionValue_type,
		{ &asn_OER_memb_extensionValue_constr_56, &asn_PER_memb_extensionValue_constr_56,  memb_extensionValue_constraint_53 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_HNBConfigTransferResponseExtensions_tags_53[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_HNBConfigTransferResponseExtensions_tag2el_53[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_HNBConfigTransferResponseExtensions_specs_53 = {
	sizeof(struct HNBConfigTransferResponseExtensions),
	offsetof(struct HNBConfigTransferResponseExtensions, _asn_ctx),
	asn_MAP_HNBConfigTransferResponseExtensions_tag2el_53,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_HNBConfigTransferResponseExtensions = {
	"HNBConfigTransferResponseExtensions",
	"HNBConfigTransferResponseExtensions",
	&asn_OP_SEQUENCE,
	asn_DEF_HNBConfigTransferResponseExtensions_tags_53,
	sizeof(asn_DEF_HNBConfigTransferResponseExtensions_tags_53)
		/sizeof(asn_DEF_HNBConfigTransferResponseExtensions_tags_53[0]), /* 1 */
	asn_DEF_HNBConfigTransferResponseExtensions_tags_53,	/* Same as above */
	sizeof(asn_DEF_HNBConfigTransferResponseExtensions_tags_53)
		/sizeof(asn_DEF_HNBConfigTransferResponseExtensions_tags_53[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_HNBConfigTransferResponseExtensions_53,
	3,	/* Elements count */
	&asn_SPC_HNBConfigTransferResponseExtensions_specs_53	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_60 = {
	sizeof(struct RelocationCompleteExtensions__extensionValue),
	offsetof(struct RelocationCompleteExtensions__extensionValue, _asn_ctx),
	offsetof(struct RelocationCompleteExtensions__extensionValue, present),
	sizeof(((struct RelocationCompleteExtensions__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_60 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_60	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_RelocationCompleteExtensions_57[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RelocationCompleteExtensions, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_58, &asn_PER_memb_id_constr_58,  memb_id_constraint_57 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RelocationCompleteExtensions, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_59, &asn_PER_memb_criticality_constr_59,  memb_criticality_constraint_57 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct RelocationCompleteExtensions, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_60,
		0,
		{ &asn_OER_memb_extensionValue_constr_60, &asn_PER_memb_extensionValue_constr_60,  memb_extensionValue_constraint_57 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RelocationCompleteExtensions_tags_57[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RelocationCompleteExtensions_tag2el_57[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_RelocationCompleteExtensions_specs_57 = {
	sizeof(struct RelocationCompleteExtensions),
	offsetof(struct RelocationCompleteExtensions, _asn_ctx),
	asn_MAP_RelocationCompleteExtensions_tag2el_57,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_RelocationCompleteExtensions = {
	"RelocationCompleteExtensions",
	"RelocationCompleteExtensions",
	&asn_OP_SEQUENCE,
	asn_DEF_RelocationCompleteExtensions_tags_57,
	sizeof(asn_DEF_RelocationCompleteExtensions_tags_57)
		/sizeof(asn_DEF_RelocationCompleteExtensions_tags_57[0]), /* 1 */
	asn_DEF_RelocationCompleteExtensions_tags_57,	/* Same as above */
	sizeof(asn_DEF_RelocationCompleteExtensions_tags_57)
		/sizeof(asn_DEF_RelocationCompleteExtensions_tags_57[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_RelocationCompleteExtensions_57,
	3,	/* Elements count */
	&asn_SPC_RelocationCompleteExtensions_specs_57	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_64 = {
	sizeof(struct ErrorIndicationExtensions__extensionValue),
	offsetof(struct ErrorIndicationExtensions__extensionValue, _asn_ctx),
	offsetof(struct ErrorIndicationExtensions__extensionValue, present),
	sizeof(((struct ErrorIndicationExtensions__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_64 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_64	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_ErrorIndicationExtensions_61[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct ErrorIndicationExtensions, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_62, &asn_PER_memb_id_constr_62,  memb_id_constraint_61 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct ErrorIndicationExtensions, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_63, &asn_PER_memb_criticality_constr_63,  memb_criticality_constraint_61 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct ErrorIndicationExtensions, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_64,
		0,
		{ &asn_OER_memb_extensionValue_constr_64, &asn_PER_memb_extensionValue_constr_64,  memb_extensionValue_constraint_61 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_ErrorIndicationExtensions_tags_61[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_ErrorIndicationExtensions_tag2el_61[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_ErrorIndicationExtensions_specs_61 = {
	sizeof(struct ErrorIndicationExtensions),
	offsetof(struct ErrorIndicationExtensions, _asn_ctx),
	asn_MAP_ErrorIndicationExtensions_tag2el_61,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_ErrorIndicationExtensions = {
	"ErrorIndicationExtensions",
	"ErrorIndicationExtensions",
	&asn_OP_SEQUENCE,
	asn_DEF_ErrorIndicationExtensions_tags_61,
	sizeof(asn_DEF_ErrorIndicationExtensions_tags_61)
		/sizeof(asn_DEF_ErrorIndicationExtensions_tags_61[0]), /* 1 */
	asn_DEF_ErrorIndicationExtensions_tags_61,	/* Same as above */
	sizeof(asn_DEF_ErrorIndicationExtensions_tags_61)
		/sizeof(asn_DEF_ErrorIndicationExtensions_tags_61[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_ErrorIndicationExtensions_61,
	3,	/* Elements count */
	&asn_SPC_ErrorIndicationExtensions_specs_61	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_68 = {
	sizeof(struct U_RNTIQueryRequestExtensions__extensionValue),
	offsetof(struct U_RNTIQueryRequestExtensions__extensionValue, _asn_ctx),
	offsetof(struct U_RNTIQueryRequestExtensions__extensionValue, present),
	sizeof(((struct U_RNTIQueryRequestExtensions__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_68 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_68	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_U_RNTIQueryRequestExtensions_65[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct U_RNTIQueryRequestExtensions, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_66, &asn_PER_memb_id_constr_66,  memb_id_constraint_65 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct U_RNTIQueryRequestExtensions, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_67, &asn_PER_memb_criticality_constr_67,  memb_criticality_constraint_65 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct U_RNTIQueryRequestExtensions, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_68,
		0,
		{ &asn_OER_memb_extensionValue_constr_68, &asn_PER_memb_extensionValue_constr_68,  memb_extensionValue_constraint_65 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_U_RNTIQueryRequestExtensions_tags_65[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_U_RNTIQueryRequestExtensions_tag2el_65[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_U_RNTIQueryRequestExtensions_specs_65 = {
	sizeof(struct U_RNTIQueryRequestExtensions),
	offsetof(struct U_RNTIQueryRequestExtensions, _asn_ctx),
	asn_MAP_U_RNTIQueryRequestExtensions_tag2el_65,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_U_RNTIQueryRequestExtensions = {
	"U-RNTIQueryRequestExtensions",
	"U-RNTIQueryRequestExtensions",
	&asn_OP_SEQUENCE,
	asn_DEF_U_RNTIQueryRequestExtensions_tags_65,
	sizeof(asn_DEF_U_RNTIQueryRequestExtensions_tags_65)
		/sizeof(asn_DEF_U_RNTIQueryRequestExtensions_tags_65[0]), /* 1 */
	asn_DEF_U_RNTIQueryRequestExtensions_tags_65,	/* Same as above */
	sizeof(asn_DEF_U_RNTIQueryRequestExtensions_tags_65)
		/sizeof(asn_DEF_U_RNTIQueryRequestExtensions_tags_65[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_U_RNTIQueryRequestExtensions_65,
	3,	/* Elements count */
	&asn_SPC_U_RNTIQueryRequestExtensions_specs_65	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_72 = {
	sizeof(struct U_RNTIQueryResponseExtensions__extensionValue),
	offsetof(struct U_RNTIQueryResponseExtensions__extensionValue, _asn_ctx),
	offsetof(struct U_RNTIQueryResponseExtensions__extensionValue, present),
	sizeof(((struct U_RNTIQueryResponseExtensions__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_72 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_72	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_U_RNTIQueryResponseExtensions_69[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct U_RNTIQueryResponseExtensions, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_70, &asn_PER_memb_id_constr_70,  memb_id_constraint_69 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct U_RNTIQueryResponseExtensions, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_71, &asn_PER_memb_criticality_constr_71,  memb_criticality_constraint_69 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct U_RNTIQueryResponseExtensions, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_72,
		0,
		{ &asn_OER_memb_extensionValue_constr_72, &asn_PER_memb_extensionValue_constr_72,  memb_extensionValue_constraint_69 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_U_RNTIQueryResponseExtensions_tags_69[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_U_RNTIQueryResponseExtensions_tag2el_69[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_U_RNTIQueryResponseExtensions_specs_69 = {
	sizeof(struct U_RNTIQueryResponseExtensions),
	offsetof(struct U_RNTIQueryResponseExtensions, _asn_ctx),
	asn_MAP_U_RNTIQueryResponseExtensions_tag2el_69,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_U_RNTIQueryResponseExtensions = {
	"U-RNTIQueryResponseExtensions",
	"U-RNTIQueryResponseExtensions",
	&asn_OP_SEQUENCE,
	asn_DEF_U_RNTIQueryResponseExtensions_tags_69,
	sizeof(asn_DEF_U_RNTIQueryResponseExtensions_tags_69)
		/sizeof(asn_DEF_U_RNTIQueryResponseExtensions_tags_69[0]), /* 1 */
	asn_DEF_U_RNTIQueryResponseExtensions_tags_69,	/* Same as above */
	sizeof(asn_DEF_U_RNTIQueryResponseExtensions_tags_69)
		/sizeof(asn_DEF_U_RNTIQueryResponseExtensions_tags_69[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_U_RNTIQueryResponseExtensions_69,
	3,	/* Elements count */
	&asn_SPC_U_RNTIQueryResponseExtensions_specs_69	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_76 = {
	sizeof(struct CriticalityDiagnostics_ExtIEs__extensionValue),
	offsetof(struct CriticalityDiagnostics_ExtIEs__extensionValue, _asn_ctx),
	offsetof(struct CriticalityDiagnostics_ExtIEs__extensionValue, present),
	sizeof(((struct CriticalityDiagnostics_ExtIEs__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_76 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_76	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_CriticalityDiagnostics_ExtIEs_73[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct CriticalityDiagnostics_ExtIEs, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_74, &asn_PER_memb_id_constr_74,  memb_id_constraint_73 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct CriticalityDiagnostics_ExtIEs, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_75, &asn_PER_memb_criticality_constr_75,  memb_criticality_constraint_73 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct CriticalityDiagnostics_ExtIEs, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_76,
		0,
		{ &asn_OER_memb_extensionValue_constr_76, &asn_PER_memb_extensionValue_constr_76,  memb_extensionValue_constraint_73 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_CriticalityDiagnostics_ExtIEs_tags_73[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_CriticalityDiagnostics_ExtIEs_tag2el_73[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_CriticalityDiagnostics_ExtIEs_specs_73 = {
	sizeof(struct CriticalityDiagnostics_ExtIEs),
	offsetof(struct CriticalityDiagnostics_ExtIEs, _asn_ctx),
	asn_MAP_CriticalityDiagnostics_ExtIEs_tag2el_73,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_CriticalityDiagnostics_ExtIEs = {
	"CriticalityDiagnostics-ExtIEs",
	"CriticalityDiagnostics-ExtIEs",
	&asn_OP_SEQUENCE,
	asn_DEF_CriticalityDiagnostics_ExtIEs_tags_73,
	sizeof(asn_DEF_CriticalityDiagnostics_ExtIEs_tags_73)
		/sizeof(asn_DEF_CriticalityDiagnostics_ExtIEs_tags_73[0]), /* 1 */
	asn_DEF_CriticalityDiagnostics_ExtIEs_tags_73,	/* Same as above */
	sizeof(asn_DEF_CriticalityDiagnostics_ExtIEs_tags_73)
		/sizeof(asn_DEF_CriticalityDiagnostics_ExtIEs_tags_73[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_CriticalityDiagnostics_ExtIEs_73,
	3,	/* Elements count */
	&asn_SPC_CriticalityDiagnostics_ExtIEs_specs_73	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_80 = {
	sizeof(struct CriticalityDiagnostics_IE_List_ExtIEs__extensionValue),
	offsetof(struct CriticalityDiagnostics_IE_List_ExtIEs__extensionValue, _asn_ctx),
	offsetof(struct CriticalityDiagnostics_IE_List_ExtIEs__extensionValue, present),
	sizeof(((struct CriticalityDiagnostics_IE_List_ExtIEs__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_80 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_80	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_CriticalityDiagnostics_IE_List_ExtIEs_77[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct CriticalityDiagnostics_IE_List_ExtIEs, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_78, &asn_PER_memb_id_constr_78,  memb_id_constraint_77 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct CriticalityDiagnostics_IE_List_ExtIEs, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_79, &asn_PER_memb_criticality_constr_79,  memb_criticality_constraint_77 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct CriticalityDiagnostics_IE_List_ExtIEs, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_80,
		0,
		{ &asn_OER_memb_extensionValue_constr_80, &asn_PER_memb_extensionValue_constr_80,  memb_extensionValue_constraint_77 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_CriticalityDiagnostics_IE_List_ExtIEs_tags_77[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_CriticalityDiagnostics_IE_List_ExtIEs_tag2el_77[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_CriticalityDiagnostics_IE_List_ExtIEs_specs_77 = {
	sizeof(struct CriticalityDiagnostics_IE_List_ExtIEs),
	offsetof(struct CriticalityDiagnostics_IE_List_ExtIEs, _asn_ctx),
	asn_MAP_CriticalityDiagnostics_IE_List_ExtIEs_tag2el_77,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_CriticalityDiagnostics_IE_List_ExtIEs = {
	"CriticalityDiagnostics-IE-List-ExtIEs",
	"CriticalityDiagnostics-IE-List-ExtIEs",
	&asn_OP_SEQUENCE,
	asn_DEF_CriticalityDiagnostics_IE_List_ExtIEs_tags_77,
	sizeof(asn_DEF_CriticalityDiagnostics_IE_List_ExtIEs_tags_77)
		/sizeof(asn_DEF_CriticalityDiagnostics_IE_List_ExtIEs_tags_77[0]), /* 1 */
	asn_DEF_CriticalityDiagnostics_IE_List_ExtIEs_tags_77,	/* Same as above */
	sizeof(asn_DEF_CriticalityDiagnostics_IE_List_ExtIEs_tags_77)
		/sizeof(asn_DEF_CriticalityDiagnostics_IE_List_ExtIEs_tags_77[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_CriticalityDiagnostics_IE_List_ExtIEs_77,
	3,	/* Elements count */
	&asn_SPC_CriticalityDiagnostics_IE_List_ExtIEs_specs_77	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_84 = {
	sizeof(struct CGI_ExtIEs__extensionValue),
	offsetof(struct CGI_ExtIEs__extensionValue, _asn_ctx),
	offsetof(struct CGI_ExtIEs__extensionValue, present),
	sizeof(((struct CGI_ExtIEs__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_84 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_84	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_CGI_ExtIEs_81[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct CGI_ExtIEs, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_82, &asn_PER_memb_id_constr_82,  memb_id_constraint_81 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct CGI_ExtIEs, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_83, &asn_PER_memb_criticality_constr_83,  memb_criticality_constraint_81 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct CGI_ExtIEs, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_84,
		0,
		{ &asn_OER_memb_extensionValue_constr_84, &asn_PER_memb_extensionValue_constr_84,  memb_extensionValue_constraint_81 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_CGI_ExtIEs_tags_81[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_CGI_ExtIEs_tag2el_81[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_CGI_ExtIEs_specs_81 = {
	sizeof(struct CGI_ExtIEs),
	offsetof(struct CGI_ExtIEs, _asn_ctx),
	asn_MAP_CGI_ExtIEs_tag2el_81,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_CGI_ExtIEs = {
	"CGI-ExtIEs",
	"CGI-ExtIEs",
	&asn_OP_SEQUENCE,
	asn_DEF_CGI_ExtIEs_tags_81,
	sizeof(asn_DEF_CGI_ExtIEs_tags_81)
		/sizeof(asn_DEF_CGI_ExtIEs_tags_81[0]), /* 1 */
	asn_DEF_CGI_ExtIEs_tags_81,	/* Same as above */
	sizeof(asn_DEF_CGI_ExtIEs_tags_81)
		/sizeof(asn_DEF_CGI_ExtIEs_tags_81[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_CGI_ExtIEs_81,
	3,	/* Elements count */
	&asn_SPC_CGI_ExtIEs_specs_81	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_88 = {
	sizeof(struct GeographicLocation_ExtIEs__extensionValue),
	offsetof(struct GeographicLocation_ExtIEs__extensionValue, _asn_ctx),
	offsetof(struct GeographicLocation_ExtIEs__extensionValue, present),
	sizeof(((struct GeographicLocation_ExtIEs__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_88 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_88	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_GeographicLocation_ExtIEs_85[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct GeographicLocation_ExtIEs, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_86, &asn_PER_memb_id_constr_86,  memb_id_constraint_85 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct GeographicLocation_ExtIEs, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_87, &asn_PER_memb_criticality_constr_87,  memb_criticality_constraint_85 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct GeographicLocation_ExtIEs, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_88,
		0,
		{ &asn_OER_memb_extensionValue_constr_88, &asn_PER_memb_extensionValue_constr_88,  memb_extensionValue_constraint_85 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_GeographicLocation_ExtIEs_tags_85[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_GeographicLocation_ExtIEs_tag2el_85[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_GeographicLocation_ExtIEs_specs_85 = {
	sizeof(struct GeographicLocation_ExtIEs),
	offsetof(struct GeographicLocation_ExtIEs, _asn_ctx),
	asn_MAP_GeographicLocation_ExtIEs_tag2el_85,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_GeographicLocation_ExtIEs = {
	"GeographicLocation-ExtIEs",
	"GeographicLocation-ExtIEs",
	&asn_OP_SEQUENCE,
	asn_DEF_GeographicLocation_ExtIEs_tags_85,
	sizeof(asn_DEF_GeographicLocation_ExtIEs_tags_85)
		/sizeof(asn_DEF_GeographicLocation_ExtIEs_tags_85[0]), /* 1 */
	asn_DEF_GeographicLocation_ExtIEs_tags_85,	/* Same as above */
	sizeof(asn_DEF_GeographicLocation_ExtIEs_tags_85)
		/sizeof(asn_DEF_GeographicLocation_ExtIEs_tags_85[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_GeographicLocation_ExtIEs_85,
	3,	/* Elements count */
	&asn_SPC_GeographicLocation_ExtIEs_specs_85	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_92 = {
	sizeof(struct GeographicalCoordinates_ExtIEs__extensionValue),
	offsetof(struct GeographicalCoordinates_ExtIEs__extensionValue, _asn_ctx),
	offsetof(struct GeographicalCoordinates_ExtIEs__extensionValue, present),
	sizeof(((struct GeographicalCoordinates_ExtIEs__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_92 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_92	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_GeographicalCoordinates_ExtIEs_89[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct GeographicalCoordinates_ExtIEs, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_90, &asn_PER_memb_id_constr_90,  memb_id_constraint_89 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct GeographicalCoordinates_ExtIEs, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_91, &asn_PER_memb_criticality_constr_91,  memb_criticality_constraint_89 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct GeographicalCoordinates_ExtIEs, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_92,
		0,
		{ &asn_OER_memb_extensionValue_constr_92, &asn_PER_memb_extensionValue_constr_92,  memb_extensionValue_constraint_89 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_GeographicalCoordinates_ExtIEs_tags_89[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_GeographicalCoordinates_ExtIEs_tag2el_89[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_GeographicalCoordinates_ExtIEs_specs_89 = {
	sizeof(struct GeographicalCoordinates_ExtIEs),
	offsetof(struct GeographicalCoordinates_ExtIEs, _asn_ctx),
	asn_MAP_GeographicalCoordinates_ExtIEs_tag2el_89,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_GeographicalCoordinates_ExtIEs = {
	"GeographicalCoordinates-ExtIEs",
	"GeographicalCoordinates-ExtIEs",
	&asn_OP_SEQUENCE,
	asn_DEF_GeographicalCoordinates_ExtIEs_tags_89,
	sizeof(asn_DEF_GeographicalCoordinates_ExtIEs_tags_89)
		/sizeof(asn_DEF_GeographicalCoordinates_ExtIEs_tags_89[0]), /* 1 */
	asn_DEF_GeographicalCoordinates_ExtIEs_tags_89,	/* Same as above */
	sizeof(asn_DEF_GeographicalCoordinates_ExtIEs_tags_89)
		/sizeof(asn_DEF_GeographicalCoordinates_ExtIEs_tags_89[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_GeographicalCoordinates_ExtIEs_89,
	3,	/* Elements count */
	&asn_SPC_GeographicalCoordinates_ExtIEs_specs_89	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_96 = {
	sizeof(struct HNB_Cell_Identifier_ExtIEs__extensionValue),
	offsetof(struct HNB_Cell_Identifier_ExtIEs__extensionValue, _asn_ctx),
	offsetof(struct HNB_Cell_Identifier_ExtIEs__extensionValue, present),
	sizeof(((struct HNB_Cell_Identifier_ExtIEs__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_96 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_96	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_HNB_Cell_Identifier_ExtIEs_93[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct HNB_Cell_Identifier_ExtIEs, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_94, &asn_PER_memb_id_constr_94,  memb_id_constraint_93 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNB_Cell_Identifier_ExtIEs, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_95, &asn_PER_memb_criticality_constr_95,  memb_criticality_constraint_93 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct HNB_Cell_Identifier_ExtIEs, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_96,
		0,
		{ &asn_OER_memb_extensionValue_constr_96, &asn_PER_memb_extensionValue_constr_96,  memb_extensionValue_constraint_93 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_HNB_Cell_Identifier_ExtIEs_tags_93[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_HNB_Cell_Identifier_ExtIEs_tag2el_93[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_HNB_Cell_Identifier_ExtIEs_specs_93 = {
	sizeof(struct HNB_Cell_Identifier_ExtIEs),
	offsetof(struct HNB_Cell_Identifier_ExtIEs, _asn_ctx),
	asn_MAP_HNB_Cell_Identifier_ExtIEs_tag2el_93,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_HNB_Cell_Identifier_ExtIEs = {
	"HNB-Cell-Identifier-ExtIEs",
	"HNB-Cell-Identifier-ExtIEs",
	&asn_OP_SEQUENCE,
	asn_DEF_HNB_Cell_Identifier_ExtIEs_tags_93,
	sizeof(asn_DEF_HNB_Cell_Identifier_ExtIEs_tags_93)
		/sizeof(asn_DEF_HNB_Cell_Identifier_ExtIEs_tags_93[0]), /* 1 */
	asn_DEF_HNB_Cell_Identifier_ExtIEs_tags_93,	/* Same as above */
	sizeof(asn_DEF_HNB_Cell_Identifier_ExtIEs_tags_93)
		/sizeof(asn_DEF_HNB_Cell_Identifier_ExtIEs_tags_93[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_HNB_Cell_Identifier_ExtIEs_93,
	3,	/* Elements count */
	&asn_SPC_HNB_Cell_Identifier_ExtIEs_specs_93	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_100 = {
	sizeof(struct HNBConfigInfo_ExtIEs__extensionValue),
	offsetof(struct HNBConfigInfo_ExtIEs__extensionValue, _asn_ctx),
	offsetof(struct HNBConfigInfo_ExtIEs__extensionValue, present),
	sizeof(((struct HNBConfigInfo_ExtIEs__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_100 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_100	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_HNBConfigInfo_ExtIEs_97[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct HNBConfigInfo_ExtIEs, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_98, &asn_PER_memb_id_constr_98,  memb_id_constraint_97 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBConfigInfo_ExtIEs, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_99, &asn_PER_memb_criticality_constr_99,  memb_criticality_constraint_97 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct HNBConfigInfo_ExtIEs, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_100,
		0,
		{ &asn_OER_memb_extensionValue_constr_100, &asn_PER_memb_extensionValue_constr_100,  memb_extensionValue_constraint_97 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_HNBConfigInfo_ExtIEs_tags_97[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_HNBConfigInfo_ExtIEs_tag2el_97[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_HNBConfigInfo_ExtIEs_specs_97 = {
	sizeof(struct HNBConfigInfo_ExtIEs),
	offsetof(struct HNBConfigInfo_ExtIEs, _asn_ctx),
	asn_MAP_HNBConfigInfo_ExtIEs_tag2el_97,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_HNBConfigInfo_ExtIEs = {
	"HNBConfigInfo-ExtIEs",
	"HNBConfigInfo-ExtIEs",
	&asn_OP_SEQUENCE,
	asn_DEF_HNBConfigInfo_ExtIEs_tags_97,
	sizeof(asn_DEF_HNBConfigInfo_ExtIEs_tags_97)
		/sizeof(asn_DEF_HNBConfigInfo_ExtIEs_tags_97[0]), /* 1 */
	asn_DEF_HNBConfigInfo_ExtIEs_tags_97,	/* Same as above */
	sizeof(asn_DEF_HNBConfigInfo_ExtIEs_tags_97)
		/sizeof(asn_DEF_HNBConfigInfo_ExtIEs_tags_97[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_HNBConfigInfo_ExtIEs_97,
	3,	/* Elements count */
	&asn_SPC_HNBConfigInfo_ExtIEs_specs_97	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_extensionValue_104[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct HNBConfigurationInformationProvided_ExtIEs__extensionValue, choice.S_RNTIPrefix),
		(ASN_TAG_CLASS_UNIVERSAL | (3 << 2)),
		0,
		&asn_DEF_S_RNTIPrefix,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"S-RNTIPrefix"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBConfigurationInformationProvided_ExtIEs__extensionValue, choice.URAIdentityList),
		(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		0,
		&asn_DEF_URAIdentityList,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"URAIdentityList"
		},
};
static const asn_TYPE_tag2member_t asn_MAP_extensionValue_tag2el_104[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (3 << 2)), 0, 0, 0 }, /* S-RNTIPrefix */
    { (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 1, 0, 0 } /* URAIdentityList */
};
static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_104 = {
	sizeof(struct HNBConfigurationInformationProvided_ExtIEs__extensionValue),
	offsetof(struct HNBConfigurationInformationProvided_ExtIEs__extensionValue, _asn_ctx),
	offsetof(struct HNBConfigurationInformationProvided_ExtIEs__extensionValue, present),
	sizeof(((struct HNBConfigurationInformationProvided_ExtIEs__extensionValue *)0)->present),
	asn_MAP_extensionValue_tag2el_104,
	2,	/* Count of tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_104 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	asn_MBR_extensionValue_104,
	2,	/* Elements count */
	&asn_SPC_extensionValue_specs_104	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_HNBConfigurationInformationProvided_ExtIEs_101[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct HNBConfigurationInformationProvided_ExtIEs, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_102, &asn_PER_memb_id_constr_102,  memb_id_constraint_101 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBConfigurationInformationProvided_ExtIEs, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		select_HNBConfigurationInformationProvided_ExtIEs_criticality_type,
		{ &asn_OER_memb_criticality_constr_103, &asn_PER_memb_criticality_constr_103,  memb_criticality_constraint_101 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct HNBConfigurationInformationProvided_ExtIEs, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_104,
		select_HNBConfigurationInformationProvided_ExtIEs_extensionValue_type,
		{ &asn_OER_memb_extensionValue_constr_104, &asn_PER_memb_extensionValue_constr_104,  memb_extensionValue_constraint_101 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_HNBConfigurationInformationProvided_ExtIEs_tags_101[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_HNBConfigurationInformationProvided_ExtIEs_tag2el_101[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_HNBConfigurationInformationProvided_ExtIEs_specs_101 = {
	sizeof(struct HNBConfigurationInformationProvided_ExtIEs),
	offsetof(struct HNBConfigurationInformationProvided_ExtIEs, _asn_ctx),
	asn_MAP_HNBConfigurationInformationProvided_ExtIEs_tag2el_101,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_HNBConfigurationInformationProvided_ExtIEs = {
	"HNBConfigurationInformationProvided-ExtIEs",
	"HNBConfigurationInformationProvided-ExtIEs",
	&asn_OP_SEQUENCE,
	asn_DEF_HNBConfigurationInformationProvided_ExtIEs_tags_101,
	sizeof(asn_DEF_HNBConfigurationInformationProvided_ExtIEs_tags_101)
		/sizeof(asn_DEF_HNBConfigurationInformationProvided_ExtIEs_tags_101[0]), /* 1 */
	asn_DEF_HNBConfigurationInformationProvided_ExtIEs_tags_101,	/* Same as above */
	sizeof(asn_DEF_HNBConfigurationInformationProvided_ExtIEs_tags_101)
		/sizeof(asn_DEF_HNBConfigurationInformationProvided_ExtIEs_tags_101[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_HNBConfigurationInformationProvided_ExtIEs_101,
	3,	/* Elements count */
	&asn_SPC_HNBConfigurationInformationProvided_ExtIEs_specs_101	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_108 = {
	sizeof(struct HNBConfigurationInformationMissing_ExtIEs__extensionValue),
	offsetof(struct HNBConfigurationInformationMissing_ExtIEs__extensionValue, _asn_ctx),
	offsetof(struct HNBConfigurationInformationMissing_ExtIEs__extensionValue, present),
	sizeof(((struct HNBConfigurationInformationMissing_ExtIEs__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_108 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_108	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_HNBConfigurationInformationMissing_ExtIEs_105[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct HNBConfigurationInformationMissing_ExtIEs, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_106, &asn_PER_memb_id_constr_106,  memb_id_constraint_105 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNBConfigurationInformationMissing_ExtIEs, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_107, &asn_PER_memb_criticality_constr_107,  memb_criticality_constraint_105 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct HNBConfigurationInformationMissing_ExtIEs, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_108,
		0,
		{ &asn_OER_memb_extensionValue_constr_108, &asn_PER_memb_extensionValue_constr_108,  memb_extensionValue_constraint_105 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_HNBConfigurationInformationMissing_ExtIEs_tags_105[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_HNBConfigurationInformationMissing_ExtIEs_tag2el_105[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_HNBConfigurationInformationMissing_ExtIEs_specs_105 = {
	sizeof(struct HNBConfigurationInformationMissing_ExtIEs),
	offsetof(struct HNBConfigurationInformationMissing_ExtIEs, _asn_ctx),
	asn_MAP_HNBConfigurationInformationMissing_ExtIEs_tag2el_105,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_HNBConfigurationInformationMissing_ExtIEs = {
	"HNBConfigurationInformationMissing-ExtIEs",
	"HNBConfigurationInformationMissing-ExtIEs",
	&asn_OP_SEQUENCE,
	asn_DEF_HNBConfigurationInformationMissing_ExtIEs_tags_105,
	sizeof(asn_DEF_HNBConfigurationInformationMissing_ExtIEs_tags_105)
		/sizeof(asn_DEF_HNBConfigurationInformationMissing_ExtIEs_tags_105[0]), /* 1 */
	asn_DEF_HNBConfigurationInformationMissing_ExtIEs_tags_105,	/* Same as above */
	sizeof(asn_DEF_HNBConfigurationInformationMissing_ExtIEs_tags_105)
		/sizeof(asn_DEF_HNBConfigurationInformationMissing_ExtIEs_tags_105[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_HNBConfigurationInformationMissing_ExtIEs_105,
	3,	/* Elements count */
	&asn_SPC_HNBConfigurationInformationMissing_ExtIEs_specs_105	/* Additional specs */
};

static asn_TYPE_member_t asn_MBR_extensionValue_112[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct HNB_Location_Information_ExtIEs__extensionValue, choice.IP_Address),
		(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
		0,
		&asn_DEF_IP_Address,
		0,
		{ 0, 0, 0 },
		0, 0, /* No default value */
		"IP-Address"
		},
};
static const asn_TYPE_tag2member_t asn_MAP_extensionValue_tag2el_112[] = {
    { (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0, 0 } /* IP-Address */
};
static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_112 = {
	sizeof(struct HNB_Location_Information_ExtIEs__extensionValue),
	offsetof(struct HNB_Location_Information_ExtIEs__extensionValue, _asn_ctx),
	offsetof(struct HNB_Location_Information_ExtIEs__extensionValue, present),
	sizeof(((struct HNB_Location_Information_ExtIEs__extensionValue *)0)->present),
	asn_MAP_extensionValue_tag2el_112,
	1,	/* Count of tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_112 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	asn_MBR_extensionValue_112,
	1,	/* Elements count */
	&asn_SPC_extensionValue_specs_112	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_HNB_Location_Information_ExtIEs_109[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct HNB_Location_Information_ExtIEs, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_110, &asn_PER_memb_id_constr_110,  memb_id_constraint_109 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNB_Location_Information_ExtIEs, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		select_HNB_Location_Information_ExtIEs_criticality_type,
		{ &asn_OER_memb_criticality_constr_111, &asn_PER_memb_criticality_constr_111,  memb_criticality_constraint_109 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct HNB_Location_Information_ExtIEs, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_112,
		select_HNB_Location_Information_ExtIEs_extensionValue_type,
		{ &asn_OER_memb_extensionValue_constr_112, &asn_PER_memb_extensionValue_constr_112,  memb_extensionValue_constraint_109 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_HNB_Location_Information_ExtIEs_tags_109[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_HNB_Location_Information_ExtIEs_tag2el_109[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_HNB_Location_Information_ExtIEs_specs_109 = {
	sizeof(struct HNB_Location_Information_ExtIEs),
	offsetof(struct HNB_Location_Information_ExtIEs, _asn_ctx),
	asn_MAP_HNB_Location_Information_ExtIEs_tag2el_109,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_HNB_Location_Information_ExtIEs = {
	"HNB-Location-Information-ExtIEs",
	"HNB-Location-Information-ExtIEs",
	&asn_OP_SEQUENCE,
	asn_DEF_HNB_Location_Information_ExtIEs_tags_109,
	sizeof(asn_DEF_HNB_Location_Information_ExtIEs_tags_109)
		/sizeof(asn_DEF_HNB_Location_Information_ExtIEs_tags_109[0]), /* 1 */
	asn_DEF_HNB_Location_Information_ExtIEs_tags_109,	/* Same as above */
	sizeof(asn_DEF_HNB_Location_Information_ExtIEs_tags_109)
		/sizeof(asn_DEF_HNB_Location_Information_ExtIEs_tags_109[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_HNB_Location_Information_ExtIEs_109,
	3,	/* Elements count */
	&asn_SPC_HNB_Location_Information_ExtIEs_specs_109	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_116 = {
	sizeof(struct HNB_Identity_ExtIEs__extensionValue),
	offsetof(struct HNB_Identity_ExtIEs__extensionValue, _asn_ctx),
	offsetof(struct HNB_Identity_ExtIEs__extensionValue, present),
	sizeof(((struct HNB_Identity_ExtIEs__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_116 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_116	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_HNB_Identity_ExtIEs_113[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct HNB_Identity_ExtIEs, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_114, &asn_PER_memb_id_constr_114,  memb_id_constraint_113 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct HNB_Identity_ExtIEs, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_115, &asn_PER_memb_criticality_constr_115,  memb_criticality_constraint_113 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct HNB_Identity_ExtIEs, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_116,
		0,
		{ &asn_OER_memb_extensionValue_constr_116, &asn_PER_memb_extensionValue_constr_116,  memb_extensionValue_constraint_113 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_HNB_Identity_ExtIEs_tags_113[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_HNB_Identity_ExtIEs_tag2el_113[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_HNB_Identity_ExtIEs_specs_113 = {
	sizeof(struct HNB_Identity_ExtIEs),
	offsetof(struct HNB_Identity_ExtIEs, _asn_ctx),
	asn_MAP_HNB_Identity_ExtIEs_tag2el_113,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_HNB_Identity_ExtIEs = {
	"HNB-Identity-ExtIEs",
	"HNB-Identity-ExtIEs",
	&asn_OP_SEQUENCE,
	asn_DEF_HNB_Identity_ExtIEs_tags_113,
	sizeof(asn_DEF_HNB_Identity_ExtIEs_tags_113)
		/sizeof(asn_DEF_HNB_Identity_ExtIEs_tags_113[0]), /* 1 */
	asn_DEF_HNB_Identity_ExtIEs_tags_113,	/* Same as above */
	sizeof(asn_DEF_HNB_Identity_ExtIEs_tags_113)
		/sizeof(asn_DEF_HNB_Identity_ExtIEs_tags_113[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_HNB_Identity_ExtIEs_113,
	3,	/* Elements count */
	&asn_SPC_HNB_Identity_ExtIEs_specs_113	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_120 = {
	sizeof(struct IP_Address_ExtIEs__extensionValue),
	offsetof(struct IP_Address_ExtIEs__extensionValue, _asn_ctx),
	offsetof(struct IP_Address_ExtIEs__extensionValue, present),
	sizeof(((struct IP_Address_ExtIEs__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_120 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_120	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_IP_Address_ExtIEs_117[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct IP_Address_ExtIEs, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_118, &asn_PER_memb_id_constr_118,  memb_id_constraint_117 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct IP_Address_ExtIEs, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_119, &asn_PER_memb_criticality_constr_119,  memb_criticality_constraint_117 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct IP_Address_ExtIEs, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_120,
		0,
		{ &asn_OER_memb_extensionValue_constr_120, &asn_PER_memb_extensionValue_constr_120,  memb_extensionValue_constraint_117 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_IP_Address_ExtIEs_tags_117[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_IP_Address_ExtIEs_tag2el_117[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_IP_Address_ExtIEs_specs_117 = {
	sizeof(struct IP_Address_ExtIEs),
	offsetof(struct IP_Address_ExtIEs, _asn_ctx),
	asn_MAP_IP_Address_ExtIEs_tag2el_117,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_IP_Address_ExtIEs = {
	"IP-Address-ExtIEs",
	"IP-Address-ExtIEs",
	&asn_OP_SEQUENCE,
	asn_DEF_IP_Address_ExtIEs_tags_117,
	sizeof(asn_DEF_IP_Address_ExtIEs_tags_117)
		/sizeof(asn_DEF_IP_Address_ExtIEs_tags_117[0]), /* 1 */
	asn_DEF_IP_Address_ExtIEs_tags_117,	/* Same as above */
	sizeof(asn_DEF_IP_Address_ExtIEs_tags_117)
		/sizeof(asn_DEF_IP_Address_ExtIEs_tags_117[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_IP_Address_ExtIEs_117,
	3,	/* Elements count */
	&asn_SPC_IP_Address_ExtIEs_specs_117	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_124 = {
	sizeof(struct MacroCoverageInformation_ExtIEs__extensionValue),
	offsetof(struct MacroCoverageInformation_ExtIEs__extensionValue, _asn_ctx),
	offsetof(struct MacroCoverageInformation_ExtIEs__extensionValue, present),
	sizeof(((struct MacroCoverageInformation_ExtIEs__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_124 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_124	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_MacroCoverageInformation_ExtIEs_121[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct MacroCoverageInformation_ExtIEs, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_122, &asn_PER_memb_id_constr_122,  memb_id_constraint_121 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct MacroCoverageInformation_ExtIEs, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_123, &asn_PER_memb_criticality_constr_123,  memb_criticality_constraint_121 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct MacroCoverageInformation_ExtIEs, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_124,
		0,
		{ &asn_OER_memb_extensionValue_constr_124, &asn_PER_memb_extensionValue_constr_124,  memb_extensionValue_constraint_121 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_MacroCoverageInformation_ExtIEs_tags_121[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_MacroCoverageInformation_ExtIEs_tag2el_121[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_MacroCoverageInformation_ExtIEs_specs_121 = {
	sizeof(struct MacroCoverageInformation_ExtIEs),
	offsetof(struct MacroCoverageInformation_ExtIEs, _asn_ctx),
	asn_MAP_MacroCoverageInformation_ExtIEs_tag2el_121,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_MacroCoverageInformation_ExtIEs = {
	"MacroCoverageInformation-ExtIEs",
	"MacroCoverageInformation-ExtIEs",
	&asn_OP_SEQUENCE,
	asn_DEF_MacroCoverageInformation_ExtIEs_tags_121,
	sizeof(asn_DEF_MacroCoverageInformation_ExtIEs_tags_121)
		/sizeof(asn_DEF_MacroCoverageInformation_ExtIEs_tags_121[0]), /* 1 */
	asn_DEF_MacroCoverageInformation_ExtIEs_tags_121,	/* Same as above */
	sizeof(asn_DEF_MacroCoverageInformation_ExtIEs_tags_121)
		/sizeof(asn_DEF_MacroCoverageInformation_ExtIEs_tags_121[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_MacroCoverageInformation_ExtIEs_121,
	3,	/* Elements count */
	&asn_SPC_MacroCoverageInformation_ExtIEs_specs_121	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_128 = {
	sizeof(struct NeighbourInfoRequestItem_ExtIEs__extensionValue),
	offsetof(struct NeighbourInfoRequestItem_ExtIEs__extensionValue, _asn_ctx),
	offsetof(struct NeighbourInfoRequestItem_ExtIEs__extensionValue, present),
	sizeof(((struct NeighbourInfoRequestItem_ExtIEs__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_128 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_128	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_NeighbourInfoRequestItem_ExtIEs_125[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct NeighbourInfoRequestItem_ExtIEs, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_126, &asn_PER_memb_id_constr_126,  memb_id_constraint_125 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct NeighbourInfoRequestItem_ExtIEs, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_127, &asn_PER_memb_criticality_constr_127,  memb_criticality_constraint_125 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct NeighbourInfoRequestItem_ExtIEs, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_128,
		0,
		{ &asn_OER_memb_extensionValue_constr_128, &asn_PER_memb_extensionValue_constr_128,  memb_extensionValue_constraint_125 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_NeighbourInfoRequestItem_ExtIEs_tags_125[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_NeighbourInfoRequestItem_ExtIEs_tag2el_125[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_NeighbourInfoRequestItem_ExtIEs_specs_125 = {
	sizeof(struct NeighbourInfoRequestItem_ExtIEs),
	offsetof(struct NeighbourInfoRequestItem_ExtIEs, _asn_ctx),
	asn_MAP_NeighbourInfoRequestItem_ExtIEs_tag2el_125,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_NeighbourInfoRequestItem_ExtIEs = {
	"NeighbourInfoRequestItem-ExtIEs",
	"NeighbourInfoRequestItem-ExtIEs",
	&asn_OP_SEQUENCE,
	asn_DEF_NeighbourInfoRequestItem_ExtIEs_tags_125,
	sizeof(asn_DEF_NeighbourInfoRequestItem_ExtIEs_tags_125)
		/sizeof(asn_DEF_NeighbourInfoRequestItem_ExtIEs_tags_125[0]), /* 1 */
	asn_DEF_NeighbourInfoRequestItem_ExtIEs_tags_125,	/* Same as above */
	sizeof(asn_DEF_NeighbourInfoRequestItem_ExtIEs_tags_125)
		/sizeof(asn_DEF_NeighbourInfoRequestItem_ExtIEs_tags_125[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_NeighbourInfoRequestItem_ExtIEs_125,
	3,	/* Elements count */
	&asn_SPC_NeighbourInfoRequestItem_ExtIEs_specs_125	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_132 = {
	sizeof(struct RABListItem_ExtIEs__extensionValue),
	offsetof(struct RABListItem_ExtIEs__extensionValue, _asn_ctx),
	offsetof(struct RABListItem_ExtIEs__extensionValue, present),
	sizeof(((struct RABListItem_ExtIEs__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_132 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_132	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_RABListItem_ExtIEs_129[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct RABListItem_ExtIEs, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_130, &asn_PER_memb_id_constr_130,  memb_id_constraint_129 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct RABListItem_ExtIEs, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_131, &asn_PER_memb_criticality_constr_131,  memb_criticality_constraint_129 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct RABListItem_ExtIEs, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_132,
		0,
		{ &asn_OER_memb_extensionValue_constr_132, &asn_PER_memb_extensionValue_constr_132,  memb_extensionValue_constraint_129 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_RABListItem_ExtIEs_tags_129[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_RABListItem_ExtIEs_tag2el_129[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_RABListItem_ExtIEs_specs_129 = {
	sizeof(struct RABListItem_ExtIEs),
	offsetof(struct RABListItem_ExtIEs, _asn_ctx),
	asn_MAP_RABListItem_ExtIEs_tag2el_129,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_RABListItem_ExtIEs = {
	"RABListItem-ExtIEs",
	"RABListItem-ExtIEs",
	&asn_OP_SEQUENCE,
	asn_DEF_RABListItem_ExtIEs_tags_129,
	sizeof(asn_DEF_RABListItem_ExtIEs_tags_129)
		/sizeof(asn_DEF_RABListItem_ExtIEs_tags_129[0]), /* 1 */
	asn_DEF_RABListItem_ExtIEs_tags_129,	/* Same as above */
	sizeof(asn_DEF_RABListItem_ExtIEs_tags_129)
		/sizeof(asn_DEF_RABListItem_ExtIEs_tags_129[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_RABListItem_ExtIEs_129,
	3,	/* Elements count */
	&asn_SPC_RABListItem_ExtIEs_specs_129	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_136 = {
	sizeof(struct TransportInfo_ExtIEs__extensionValue),
	offsetof(struct TransportInfo_ExtIEs__extensionValue, _asn_ctx),
	offsetof(struct TransportInfo_ExtIEs__extensionValue, present),
	sizeof(((struct TransportInfo_ExtIEs__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_136 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_136	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_TransportInfo_ExtIEs_133[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct TransportInfo_ExtIEs, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_134, &asn_PER_memb_id_constr_134,  memb_id_constraint_133 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct TransportInfo_ExtIEs, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_135, &asn_PER_memb_criticality_constr_135,  memb_criticality_constraint_133 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct TransportInfo_ExtIEs, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_136,
		0,
		{ &asn_OER_memb_extensionValue_constr_136, &asn_PER_memb_extensionValue_constr_136,  memb_extensionValue_constraint_133 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_TransportInfo_ExtIEs_tags_133[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_TransportInfo_ExtIEs_tag2el_133[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_TransportInfo_ExtIEs_specs_133 = {
	sizeof(struct TransportInfo_ExtIEs),
	offsetof(struct TransportInfo_ExtIEs, _asn_ctx),
	asn_MAP_TransportInfo_ExtIEs_tag2el_133,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_TransportInfo_ExtIEs = {
	"TransportInfo-ExtIEs",
	"TransportInfo-ExtIEs",
	&asn_OP_SEQUENCE,
	asn_DEF_TransportInfo_ExtIEs_tags_133,
	sizeof(asn_DEF_TransportInfo_ExtIEs_tags_133)
		/sizeof(asn_DEF_TransportInfo_ExtIEs_tags_133[0]), /* 1 */
	asn_DEF_TransportInfo_ExtIEs_tags_133,	/* Same as above */
	sizeof(asn_DEF_TransportInfo_ExtIEs_tags_133)
		/sizeof(asn_DEF_TransportInfo_ExtIEs_tags_133[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_TransportInfo_ExtIEs_133,
	3,	/* Elements count */
	&asn_SPC_TransportInfo_ExtIEs_specs_133	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_140 = {
	sizeof(struct Tunnel_Information_ExtIEs__extensionValue),
	offsetof(struct Tunnel_Information_ExtIEs__extensionValue, _asn_ctx),
	offsetof(struct Tunnel_Information_ExtIEs__extensionValue, present),
	sizeof(((struct Tunnel_Information_ExtIEs__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_140 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_140	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_Tunnel_Information_ExtIEs_137[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct Tunnel_Information_ExtIEs, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_138, &asn_PER_memb_id_constr_138,  memb_id_constraint_137 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct Tunnel_Information_ExtIEs, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_139, &asn_PER_memb_criticality_constr_139,  memb_criticality_constraint_137 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct Tunnel_Information_ExtIEs, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_140,
		0,
		{ &asn_OER_memb_extensionValue_constr_140, &asn_PER_memb_extensionValue_constr_140,  memb_extensionValue_constraint_137 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_Tunnel_Information_ExtIEs_tags_137[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_Tunnel_Information_ExtIEs_tag2el_137[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_Tunnel_Information_ExtIEs_specs_137 = {
	sizeof(struct Tunnel_Information_ExtIEs),
	offsetof(struct Tunnel_Information_ExtIEs, _asn_ctx),
	asn_MAP_Tunnel_Information_ExtIEs_tag2el_137,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_Tunnel_Information_ExtIEs = {
	"Tunnel-Information-ExtIEs",
	"Tunnel-Information-ExtIEs",
	&asn_OP_SEQUENCE,
	asn_DEF_Tunnel_Information_ExtIEs_tags_137,
	sizeof(asn_DEF_Tunnel_Information_ExtIEs_tags_137)
		/sizeof(asn_DEF_Tunnel_Information_ExtIEs_tags_137[0]), /* 1 */
	asn_DEF_Tunnel_Information_ExtIEs_tags_137,	/* Same as above */
	sizeof(asn_DEF_Tunnel_Information_ExtIEs_tags_137)
		/sizeof(asn_DEF_Tunnel_Information_ExtIEs_tags_137[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_Tunnel_Information_ExtIEs_137,
	3,	/* Elements count */
	&asn_SPC_Tunnel_Information_ExtIEs_specs_137	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_144 = {
	sizeof(struct UE_Capabilities_ExtIEs__extensionValue),
	offsetof(struct UE_Capabilities_ExtIEs__extensionValue, _asn_ctx),
	offsetof(struct UE_Capabilities_ExtIEs__extensionValue, present),
	sizeof(((struct UE_Capabilities_ExtIEs__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_144 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_144	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_UE_Capabilities_ExtIEs_141[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct UE_Capabilities_ExtIEs, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_142, &asn_PER_memb_id_constr_142,  memb_id_constraint_141 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct UE_Capabilities_ExtIEs, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_143, &asn_PER_memb_criticality_constr_143,  memb_criticality_constraint_141 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct UE_Capabilities_ExtIEs, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_144,
		0,
		{ &asn_OER_memb_extensionValue_constr_144, &asn_PER_memb_extensionValue_constr_144,  memb_extensionValue_constraint_141 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_UE_Capabilities_ExtIEs_tags_141[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_UE_Capabilities_ExtIEs_tag2el_141[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_UE_Capabilities_ExtIEs_specs_141 = {
	sizeof(struct UE_Capabilities_ExtIEs),
	offsetof(struct UE_Capabilities_ExtIEs, _asn_ctx),
	asn_MAP_UE_Capabilities_ExtIEs_tag2el_141,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_UE_Capabilities_ExtIEs = {
	"UE-Capabilities-ExtIEs",
	"UE-Capabilities-ExtIEs",
	&asn_OP_SEQUENCE,
	asn_DEF_UE_Capabilities_ExtIEs_tags_141,
	sizeof(asn_DEF_UE_Capabilities_ExtIEs_tags_141)
		/sizeof(asn_DEF_UE_Capabilities_ExtIEs_tags_141[0]), /* 1 */
	asn_DEF_UE_Capabilities_ExtIEs_tags_141,	/* Same as above */
	sizeof(asn_DEF_UE_Capabilities_ExtIEs_tags_141)
		/sizeof(asn_DEF_UE_Capabilities_ExtIEs_tags_141[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_UE_Capabilities_ExtIEs_141,
	3,	/* Elements count */
	&asn_SPC_UE_Capabilities_ExtIEs_specs_141	/* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_extensionValue_specs_148 = {
	sizeof(struct UTRANCellID_ExtIEs__extensionValue),
	offsetof(struct UTRANCellID_ExtIEs__extensionValue, _asn_ctx),
	offsetof(struct UTRANCellID_ExtIEs__extensionValue, present),
	sizeof(((struct UTRANCellID_ExtIEs__extensionValue *)0)->present),
	0,	/* No top level tags */
	0,	/* No tags in the map */
	0, 0,
	-1	/* Extensions start */
};
static /* Use -fall-defs-global to expose */
asn_TYPE_descriptor_t asn_DEF_extensionValue_148 = {
	"extensionValue",
	"extensionValue",
	&asn_OP_OPEN_TYPE,
	0,	/* No effective tags (pointer) */
	0,	/* No effective tags (count) */
	0,	/* No tags (pointer) */
	0,	/* No tags (count) */
	{ 0, 0, OPEN_TYPE_constraint },
	0, 0,	/* No members */
	&asn_SPC_extensionValue_specs_148	/* Additional specs */
};

asn_TYPE_member_t asn_MBR_UTRANCellID_ExtIEs_145[] = {
	{ ATF_NOFLAGS, 0, offsetof(struct UTRANCellID_ExtIEs, id),
		(ASN_TAG_CLASS_CONTEXT | (0 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_ProtocolIE_ID,
		0,
		{ &asn_OER_memb_id_constr_146, &asn_PER_memb_id_constr_146,  memb_id_constraint_145 },
		0, 0, /* No default value */
		"id"
		},
	{ ATF_NOFLAGS, 0, offsetof(struct UTRANCellID_ExtIEs, criticality),
		(ASN_TAG_CLASS_CONTEXT | (1 << 2)),
		-1,	/* IMPLICIT tag at current level */
		&asn_DEF_Criticality,
		0,
		{ &asn_OER_memb_criticality_constr_147, &asn_PER_memb_criticality_constr_147,  memb_criticality_constraint_145 },
		0, 0, /* No default value */
		"criticality"
		},
	{ ATF_OPEN_TYPE | ATF_NOFLAGS, 0, offsetof(struct UTRANCellID_ExtIEs, extensionValue),
		(ASN_TAG_CLASS_CONTEXT | (2 << 2)),
		+1,	/* EXPLICIT tag at current level */
		&asn_DEF_extensionValue_148,
		0,
		{ &asn_OER_memb_extensionValue_constr_148, &asn_PER_memb_extensionValue_constr_148,  memb_extensionValue_constraint_145 },
		0, 0, /* No default value */
		"extensionValue"
		},
};
static const ber_tlv_tag_t asn_DEF_UTRANCellID_ExtIEs_tags_145[] = {
	(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))
};
static const asn_TYPE_tag2member_t asn_MAP_UTRANCellID_ExtIEs_tag2el_145[] = {
    { (ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0 }, /* id */
    { (ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0 }, /* criticality */
    { (ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0 } /* extensionValue */
};
asn_SEQUENCE_specifics_t asn_SPC_UTRANCellID_ExtIEs_specs_145 = {
	sizeof(struct UTRANCellID_ExtIEs),
	offsetof(struct UTRANCellID_ExtIEs, _asn_ctx),
	asn_MAP_UTRANCellID_ExtIEs_tag2el_145,
	3,	/* Count of tags in the map */
	0, 0, 0,	/* Optional elements (not needed) */
	-1,	/* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_UTRANCellID_ExtIEs = {
	"UTRANCellID-ExtIEs",
	"UTRANCellID-ExtIEs",
	&asn_OP_SEQUENCE,
	asn_DEF_UTRANCellID_ExtIEs_tags_145,
	sizeof(asn_DEF_UTRANCellID_ExtIEs_tags_145)
		/sizeof(asn_DEF_UTRANCellID_ExtIEs_tags_145[0]), /* 1 */
	asn_DEF_UTRANCellID_ExtIEs_tags_145,	/* Same as above */
	sizeof(asn_DEF_UTRANCellID_ExtIEs_tags_145)
		/sizeof(asn_DEF_UTRANCellID_ExtIEs_tags_145[0]), /* 1 */
	{ 0, 0, SEQUENCE_constraint },
	asn_MBR_UTRANCellID_ExtIEs_145,
	3,	/* Elements count */
	&asn_SPC_UTRANCellID_ExtIEs_specs_145	/* Additional specs */
};

